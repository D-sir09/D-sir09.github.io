<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL索引入门</title>
    <link href="/2022/11/20/MySQL%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/20/MySQL%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>给数据库中的某一列加上索引后，可以提高查找速度。这是因为，索引将按照 <strong>B+树</strong> 数据结构来存储数据。<strong>B+树</strong> 将数据存在树的最底层，在数据量大时具有更快的查找速度。缺点是只加快了查找速度，增加、删除、插入数据的速度都是减慢了的，也因此，索引更适用于读多的场景。</p><p>MySQL 中，可以指定两个不同的引擎，它们使用的B+数结构有些许不同。</p><ul><li>InnoDB：聚簇索引，数据和 主键索引结构 存储在一起。MySQL5.5 后的默认索引引擎，支持事务，行级锁、外键。</li><li>MyISAM：非聚簇索引，数据 和 索引结构 分开存储。也就是说，非聚簇索引查询时将比聚簇索引多查询一次。</li></ul><h2 id="常见的索引及其创建"><a href="#常见的索引及其创建" class="headerlink" title="常见的索引及其创建"></a>常见的索引及其创建</h2><ul><li>主键索引：加速查找、不能为空、不能重复。支持多列</li><li>唯一索引：加速查找、不能重复。支持多列</li><li>普通索引：加速查找。支持多列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 主键和联合主键索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment <span class="hljs-keyword">primary</span> key,<span class="hljs-comment">-- 主键</span><br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><span class="hljs-keyword">primary</span> key(id)<br>);<br>    <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-keyword">primary</span> key(列<span class="hljs-number">1</span>，列<span class="hljs-number">2</span>)<span class="hljs-comment">-- 若有多列，称为联合主键(MyISAM引擎支持，不常用)</span><br>);<br><br><span class="hljs-comment">-- 也可以给已有的表 增加/删除 索引</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(列名);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br><br><span class="hljs-comment">-- 删除索引时可能会报错，如：自增列必须定义为键。</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表 change id id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">-- 令字段属性不再自增</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 唯一和联合唯一索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-keyword">unique</span> ix_name (name)<span class="hljs-comment">-- 单列，唯一索引</span><br>    <span class="hljs-keyword">unique</span> ix_email (email)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-keyword">unique</span> (列<span class="hljs-number">1</span>,列<span class="hljs-number">2</span>)<span class="hljs-comment">-- 多列，称为联合唯一索引（允许某一列重复，但不能所有列都一样）</span><br>);<br><br><span class="hljs-comment">-- 给已有的表 增加/删除 索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> <span class="hljs-keyword">table</span> index 索引名 <span class="hljs-keyword">on</span> 表名(列名);<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">unique</span> index 索引名 <span class="hljs-keyword">on</span> 表名;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 索引和联合索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    index ix_email (email)<br>    index ix_name (name)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    index ix_email (name,email)<span class="hljs-comment">-- 多列，称为联合索引。</span><br>);<br><br><span class="hljs-comment">-- 给已有的表 增加/删除 索引</span><br><span class="hljs-keyword">create</span> index 索引名 <span class="hljs-keyword">on</span> 表名(列名);<br><br><span class="hljs-keyword">drop</span> index 索引名 <span class="hljs-keyword">on</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>注意事项</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 一般情况下，针对索引列的搜索都可以命中索引（通过索引结构加速查找）</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> email <span class="hljs-operator">=</span> &quot;2734306201@qq.com&quot;;<br><br><span class="hljs-comment">-- 无法命中索引的情况（除了主键，大多数情况下，主键都可命中索引）</span><br><br><span class="hljs-comment">-- 1、类型不一致</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<span class="hljs-comment">-- 未命中</span><br><br><span class="hljs-comment">-- 2、使用了不等于</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> name <span class="hljs-operator">!=</span> &quot;zhangsan&quot;;<span class="hljs-comment">-- 未命中</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> id <span class="hljs-operator">!=</span> <span class="hljs-number">123</span>; <span class="hljs-comment">-- 特殊的主键，命中</span><br><br><span class="hljs-comment">-- 3、使用了 or，且 or 条件中有未建立索引的列</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <span class="hljs-keyword">or</span> password <span class="hljs-operator">=</span> &quot;xx&quot;;<span class="hljs-comment">-- 未命中</span><br><br><span class="hljs-comment">-- 4、排序，当根据索引排序时，选择的映射如果不是索引，则不走索引</span><br><br><span class="hljs-comment">-- 5、like 进行模糊匹配时</span><br><br><span class="hljs-comment">-- 6、使用函数查询时</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> reverse(name) <span class="hljs-operator">=</span> &quot;zhangsan&quot;;<span class="hljs-comment">-- 未命中。但是先翻转再赋值则可以命中</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> reverse(&quot;zhangsan&quot;);<br><br><span class="hljs-comment">-- 7、联合索引时遵循最左前缀原则。比如：联合索引 (name, password)</span><br>name <span class="hljs-keyword">and</span> password <span class="hljs-comment">-- 命中</span><br>name<span class="hljs-comment">-- 命中</span><br>password<span class="hljs-comment">-- 未命中</span><br>name <span class="hljs-keyword">or</span> password<span class="hljs-comment">-- 未命中</span><br></code></pre></td></tr></table></figure><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p><code>explain + SQL 语句;</code> 这段语句可以指定 SQL 的执行。有多种类型，性能排行：</p><p><code>all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; system/const</code></p><ul><li>ALL，全表扫描，数据表从头到尾找一遍，且一般不会命中索引：<code>select * from big;</code></li><li>INDEX，全索引扫描，对索引从头到尾找一遍：<code>explain select id from big; </code></li><li>RANGE，对索引列进行范围查找：<code>explain select * from big where id &gt; 10;</code></li><li>INDEX_MERGE，合并索引，使用多个单列索引搜索：<code>explain select * from big where id = 10 or name = &quot;zhangsan&quot;;</code></li><li>REF，根据索引直接查找（非键）：<code>select * from big where name = &#39;zhangsan&#39;</code>;</li><li>EQ_REF，连表操作时常见：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> big.name, users.id <span class="hljs-keyword">from</span> big <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> users <span class="hljs-keyword">on</span> big.age <span class="hljs-operator">=</span> users.id;<br></code></pre></td></tr></table></figure><ul><li>CONST，常量，表最多有一个匹配行，在这行的列值可被优化器剩余部分认为是常数，const表很快。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<span class="hljs-comment">-- 主键</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> email <span class="hljs-operator">=</span> &quot;2734306201@qq.com&quot;;<span class="hljs-comment">-- 唯一索引</span><br></code></pre></td></tr></table></figure><ul><li>SYSTEM，表仅有一行（系统表）。CONST 联接类型的一个特例。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> big <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> limit <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> A;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go常见关键字的底层</title>
    <link href="/2022/11/08/Go%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82/"/>
    <url>/2022/11/08/Go%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>一个 <strong>slice</strong>（切片）有三个基本属性：<strong>data，len，cap</strong> 分别代表切片里含有的元素，切片的长度、容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建切片</span><br><span class="hljs-keyword">var</span> ints []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)<br>ints = <span class="hljs-built_in">append</span>(ints,<span class="hljs-number">1</span>) <span class="hljs-comment">//附加元素 ‘1‘ 于 ints 后，既 int[2]</span><br>ints[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment">//此时变量 ints 中：ints[0] ints[1] ints[2]</span><br><span class="hljs-comment">//  |   1   |   0   |   1   |</span><br><span class="hljs-comment">//此时，如何访问 ints[2] 之后的元素 如 ints[3]，会发生 panic，因为数组越界</span><br><br><span class="hljs-comment">//也可以这样创建切片, 这同样会有data，len，cap属性</span><br><span class="hljs-comment">//new 初始化出一个指向 data 的指针，此时未分配内存空间，data，len，cap 对应的属性为 nil，0，0</span><br>ps := <span class="hljs-built_in">new</span>([]<span class="hljs-type">string</span>)<br><br><span class="hljs-comment">//给 ps 赋值需要使用 append</span><br>*ps = <span class="hljs-built_in">append</span>(*ps, <span class="hljs-string">&quot;GoGoGo&quot;</span>)<br><span class="hljs-comment">//附加元素后，此时，data，len，cap 对应 data，1，1。其中，data 中包含 “GoGoGO” 以及它的字符长度</span><br><br></code></pre></td></tr></table></figure><p>slice 实际上是指向数组的指针，<strong>data</strong> 属性内就是它所指向的数组， 注意，slice 并不总是指向数组的首地址。<strong>数组</strong> 的 <strong>容量</strong> 声明了之后就不能再改变，当 slice 进行 append 时，若其指向的数组 <strong>容量不足</strong>，那么，slice 将会扩容数组：首先，<strong>复制</strong> 原数组的元素到另一个数组中，而后，附加元素，最后，slice 再指向新的数组。</p><blockquote><p>slice 扩容的规则：</p><ul><li>若扩容前，旧的数组的容量 &lt; 1024，那么，新的数组的容量为旧的数组的 2 倍（newCap &#x3D; oldCap * 2 ），直到容量能够容纳所添加的新元素。</li><li>若旧的数组的容量  &gt; 1024，那么新的数组的容量为旧的数组的 1.25 倍（newCap &#x3D; oldCap * 1.25），直到足够容纳新添加的元素。</li></ul><p>1.18版本更新后，扩容变更：</p><ul><li>原 slice 容量(oldcap) &lt; 256 的时候，新 slice(newcap) 容量为原来的2倍。</li><li>原slice容量超过 256，新 slice 容量 newcap &#x3D; oldcap + (oldcap + 3*256) &#x2F; 4</li></ul></blockquote><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><strong>map</strong> 是由 &lt;key, value&gt; 对组成的抽象数据结构，同一个 key 只会出现一次。它的底层实现是哈希表，通常哈希表在存储键值对时，会选择一个桶，常见的选择方法有两种：<strong>取模法</strong> 和 <strong>与运算（这种方式限制桶的个数必须是2的整数次幂 - 1）</strong>。Go 中的 map 实际上是一个指向 hmap 结构体的指针，选择桶的方法是与运算：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    count <span class="hljs-type">int</span><span class="hljs-comment">//元素个数，len(map)将返回这个值</span><br>    flags <span class="hljs-type">uint8</span><span class="hljs-comment">//标识 map 状态</span><br>    <span class="hljs-comment">//当 count/(2^B) &gt; 6.5时，hmap 会扩容（*2）</span><br>    B <span class="hljs-type">uint8</span><span class="hljs-comment">//负载因子。记录桶的数目是 2 的 B 次幂，以待扩容</span><br>    noverflow <span class="hljs-type">uint16</span><span class="hljs-comment">//溢出 buckets 的数量</span><br>    hash0<span class="hljs-type">uint32</span><span class="hljs-comment">//hash 种子</span><br>    <br>    bucketsunsafe.Pointer<span class="hljs-comment">//桶， 主要的存储结构</span><br>    oldbucketsunsafe.Pointer<span class="hljs-comment">//旧桶（扩容时用）</span><br>    nevacuate <span class="hljs-type">uintptr</span><span class="hljs-comment">//扩容阶段，下一个要迁移的旧桶的编号</span><br>    <br>    extra *mapextra<span class="hljs-comment">//可选字段，额外信息</span><br>&#125;<br><br><span class="hljs-comment">//编译阶段，buckets 会产生新的结构体 bmap。一个桶里最多装入 8 个 key</span><br><span class="hljs-comment">//若有第九个 kv 落入当前的 bucket，将再构建一个 bucket，通过 overflow 指针连接起来</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存储哈希值的高 8 位</span><br>    data    <span class="hljs-type">byte</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">//key value数据:key/key/key/.../value/value/value...</span><br>    overflow *bmap   <span class="hljs-comment">//溢出bucket的地址</span><br>&#125;<br><br><span class="hljs-comment">//额外信息</span><br> <span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>     overflow    *[]*bmap<span class="hljs-comment">//已使用的溢出桶的地址</span><br>     oldoverflow *[]*bmap<span class="hljs-comment">//旧桶使用的溢出桶的地址</span><br>     nextOverflow *bmap<span class="hljs-comment">//溢出桶</span><br><br><span class="hljs-comment">//map 相关的主要操作有：</span><br><span class="hljs-comment">/* 创建map */</span><br>countryCapitalMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;France&quot;</span>: <span class="hljs-string">&quot;Paris&quot;</span>, <br>                                       <span class="hljs-string">&quot;Italy&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>,<br>                                       <span class="hljs-string">&quot;Japan&quot;</span>:<span class="hljs-string">&quot;Tokyo&quot;</span>,<br>                                       <span class="hljs-string">&quot;India&quot;</span>: <span class="hljs-string">&quot;New delhi&quot;</span>&#125;<br><br><span class="hljs-comment">/* 打印地图 */</span><br>        <span class="hljs-keyword">for</span> country := <span class="hljs-keyword">range</span> countryCapitalMap &#123;<br>                fmt.Println(country, <span class="hljs-string">&quot;首都是&quot;</span>, countryCapitalMap [ country ])<br>        &#125;<br>     <br><span class="hljs-comment">//1. 增加一个键值对</span><br>     countryCapitalMap[<span class="hljs-string">&quot;China&quot;</span>] = <span class="hljs-string">&quot;BeiJing&quot;</span><br><span class="hljs-comment">//2. 删除一个键值对</span><br>     <span class="hljs-built_in">delete</span>(countryCapitalMap, <span class="hljs-string">&quot;Italy&quot;</span>)<br><span class="hljs-comment">//3. 修改某个 k 对应的 v：Reassign；</span><br>     countryCapitalMap[<span class="hljs-string">&quot;France&quot;</span>] =  <span class="hljs-string">&quot;nil&quot;</span><br><span class="hljs-comment">//4. 查询某个 k 对应的 v</span><br>     <span class="hljs-comment">/*查看元素在集合中是否存在 */</span><br>     <span class="hljs-comment">/*如果存在&quot;American&quot;键,返“American”的值，ok为true，否则capital的值为对应类型的零值，ok为false */</span><br>    capital, ok := countryCapitalMap [ <span class="hljs-string">&quot;American&quot;</span> ] <br>    <span class="hljs-comment">/*fmt.Println(capital) */</span><br>    <span class="hljs-comment">/*fmt.Println(ok) */</span><br>    <span class="hljs-keyword">if</span> (ok) &#123;<br>        fmt.Println(<span class="hljs-string">&quot;American 的首都是&quot;</span>, capital)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;American 的首都不存在&quot;</span>)<br>    &#125;<br>     <span class="hljs-comment">//另一种方式。如果不存在这样的 key，返回一个 key 对应 value 类型的零值。</span><br>     <span class="hljs-built_in">cap</span> := countryCapitalMap [ <span class="hljs-string">&quot;American&quot;</span> ] <br></code></pre></td></tr></table></figure><p>map 又可以称为字典、符号表，主要有两种数据结构：<strong>哈希查找表（Hash table）</strong>和 <strong>搜索树（Search tree）</strong>。</p><ul><li>哈希查找表（Go 的 Map 采用的方法）：用一个哈希函数将 <strong>key 分配到不同的桶</strong>（bucket，可以理解为数组的不同索引）。这样，<strong>开销</strong> 主要在 <strong>哈希函数的计算</strong> 以及 <strong>数组的常数访问</strong> 时间。在很多场景下，哈希查找表的性能很高。哈希查找表存在“碰撞”问题，常称为“哈希冲突”，表现为不同的 key 被分配到同一个 bucket。针对这个问题，通常用两种方法：<ul><li>链表法：将一个 bucket 实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表（Java 中，链表到了一定长度后，会改用红黑树）。</li><li>开放地址法：哈希冲突发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。</li></ul></li><li>搜索树：搜索树法一般采用平衡二叉树，比如：AVL 树，红黑树。</li></ul><blockquote><p><strong>对比</strong></p><p>搜索效率：自平衡搜索树法的搜索效率是 O(logN)，而哈希查找表最差是 O(N)。但是，哈希查找表的平均查找效率是 O(1)，而且如果哈希函数设计的很好，最坏的情况基本不会出现。</p><p>遍历特性：遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。</p></blockquote><h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><p>哈希冲突会影响哈希表的读写效率，适时对哈希表 <strong>扩容</strong> 可以保障哈希表的读写效率。我们通常把 <strong>存储键值对的数目</strong> 与 <strong>桶</strong> 的数目的 <strong>比值</strong> 作为判断依据。这个比值就叫 <strong>负载因子</strong>。</p><p>扩容时，将分配更多的桶（bucket），称为新桶。扩容时，若一次性把旧桶中的所有键值对都迁入新桶，可能会花大量时间，因此，目前常见的做法是，先分配新桶，然后用 <strong>一个字段记录旧桶</strong> 的位置，再用一个字段记录旧桶迁移的进度（比如，记录下一个要迁移的旧桶的编号），当哈希表每次进行读写操作时，若检测到当前处于扩容阶段，则完成部分旧桶迁移，直到所有旧桶迁移完成。把迁移时间分摊到多次哈希表操作中，这种方式又称为 <strong>渐进式扩容</strong>，能够避免一次性扩容带来的性能瞬时抖动。</p><blockquote><p>Go 中的 buckets 扩容后不会被 GC 回收，这意味着，大流量涌入 map 后，即使删除了所有 kv，因扩容而创建的 buckets 仍然在占用内存，造成内存泄漏。好在，一般有大流量冲击的互联网业务都是 toC 场景，上线频率高，通常在问题暴露前已经重启恢复了。</p></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>由于 map 有操作边扩容的场景，因此，不能简单的遍历所有的 bucket 以及其背后挂的 overflow bucket，因为扩容并不是原子操作。遍历时需要区分新老 bucket，这是难点所在。</p><p>&#x2F;&#x2F;待补充…</p><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>Go 是一种静态语言，这意味着它会在编译期间检查数据类型，而不像动态语言那样，对于类型不匹配的错误，只有运行到对应的代码时才会报错。当然，动态语言的这种特点可以让人更专注于业务上，代码简短，写起来更快速。</p><p>比如，在动态语言 python 中，定义一个这样的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>(<span class="hljs-params">coder</span>):<br>    coder.say_hello()<br></code></pre></td></tr></table></figure><p>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，运行过程中会出现错误。</p><p>Go 语言虽然是静态语言，但它引入了动态语言的便利，做了个折中的方案：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义一个接口，和使用此接口作为参数的函数：</span><br><span class="hljs-keyword">type</span> IGreeting <span class="hljs-keyword">interface</span> &#123;<br>sayHello()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(i IGreeting)</span></span> &#123;<br>i.sayHello()<br>&#125;<br><br><span class="hljs-comment">//定义结构体，实现接口的函数</span><br><span class="hljs-keyword">type</span> Go <span class="hljs-keyword">struct</span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g Go)</span></span> sayHello() &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hi, I am GO!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> PHP <span class="hljs-keyword">struct</span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p PHP)</span></span> sayHello() &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hi, I am PHP!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//运行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>golang := Go&#123;&#125;<br>php := PHP&#123;&#125;<br><br>sayHello(golang)<br>sayHello(php)<br>    <span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">    Hi, I am GO!</span><br><span class="hljs-comment">Hi, I am PHP!</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译器在调用 sayHello() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。这也就实现了调用 sayHello() 函数时，<code>golang, php</code> 对象虽然没有显式地声明实现了 IGreeting 类型，但是仍然能正常输出。</p><p>&#x2F;&#x2F;待补充…</p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>Go 通过 <strong>通信</strong> 共享内存，而非通过共享内存进行通信。channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建 channel,缓冲区大小为 5</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;待补充…</p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>Go 语言中的调度器基于GPM模型</p><ul><li>G（goroutine）包含表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。goroutine 的创建和销毁皆由 <code>Go runtime</code> 负责。</li><li>P（Processor）维护一个处于 Runnable 状态的 <code>g</code> 队列，<code>m</code> 需要获得 <code>p</code> 才能运行 <code>g</code>。当一个线程阻塞时，和它绑定的 p 上的 goroutine 将转移到其他线程</li><li>M（Machine）即内核级线程，包含正在运行的 goroutine 等字段。M 保存了自身使用的栈信息、当前正在 M 上执行的 G 信息、与之绑定的 P 信息……</li></ul><p>程序启动后，Go 会将每个 CPU 逻辑核心分配一个 <code>P</code>，再为每个 P 分配一个 <code>M</code>。P 和 M 创建的内核线程由操作系统调度，G 创建的用户级线程由 Go 程序调度。</p><blockquote><p>Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。</p><p>在同一时刻，一个线程上只能跑一个 goroutine。当 goroutine 发生阻塞（例如上篇文章提到的向一个 channel 发送数据，被阻塞）时，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两种高效的并发模式</title>
    <link href="/2022/10/08/%E9%AB%98%E5%B9%B6%E5%8F%91_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/08/%E9%AB%98%E5%B9%B6%E5%8F%91_%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="两种高效的并发模式"><a href="#两种高效的并发模式" class="headerlink" title="两种高效的并发模式"></a>两种高效的并发模式</h1><p>并发编程的目的是让程序 “同时” 执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。但如果程序是 <strong>I&#x2F;O密集型</strong> 的，比如经常读写文件，访问数据库等，则情况就不同了。由于 <strong>I&#x2F;O操作</strong> 的速度远没有 CPU 的计算速度快，所以让程序阻塞于 I&#x2F;O操作将浪费大量的 CPU 时间。如果程序有多个执行线程，则当前 <strong>被 I&#x2F;O 操作所阻塞的执行线程</strong> 可 <strong>主动放弃 CPU</strong>（或者由操作系统来调度），并将执行权转移到其他线程。这样一来，CPU 就可以用来做更多有意义的事情（除非所有线程都同时被 I&#x2F;O 操作所阻塞），而不是等待 I&#x2F;O 操作完成，因此 CPU 的利用率显著提升。</p><p>从实现上来说，并发编程主要有 <strong>多进程</strong> 和 <strong>多线程</strong> 两种方式，并发模式是指 <strong>I&#x2F;O处理单元</strong> 和 <strong>多个逻辑单元</strong> 之间协调完成任务的方法。服务器主要有两种并发编程模式：<strong>半同步&#x2F;半异步</strong>（half-sync&#x2F;half-async） 模式和 <strong>领导者&#x2F;追随者</strong>（Leader&#x2F;Followers）模式。</p><h2 id="半同步-x2F-半异步模式"><a href="#半同步-x2F-半异步模式" class="headerlink" title="半同步&#x2F;半异步模式"></a>半同步&#x2F;半异步模式</h2><p>这里的 “<strong>同步</strong>” 指的是程序完全按照 <strong>代码序列</strong> 的顺序执行；“<strong>异步</strong>” 指的是程序的执行需要由 <strong>系统事件</strong> 来驱动。常见的系统事件包括中断、信号等。</p><p>按照 <strong>同步方式</strong> 运行的线程称为 <strong>同步线程</strong>，按照 <strong>异步方式</strong> 运行的线程称为 <strong>异步线程</strong>。显然，<strong>异步线程</strong> 的执行 <strong>效率高，实时性强</strong>，这也是很多嵌入式程序采用的模型。但编写以异步方式执行的程序 <strong>相对复杂，难于调试和扩展</strong>，而且 <strong>不适合于大量的并发</strong>。而 <strong>同步线程</strong> 则相反，它虽然效率相对较低，实时性较差，但逻辑简单。对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们就应该同时使用同步线程和异步线程来实现，也即是 <strong>半同步&#x2F;半异步模式</strong>。</p><p>半同步&#x2F;半异步模式中，<strong>同步线程</strong> 用于处理 <strong>客户逻辑</strong>，<strong>异步线程</strong> 用于处理 <strong>I&#x2F;O事件</strong>。</p><ul><li>异步线程 <strong>监听</strong> 到客户请求后，就将其封装成请求对象并插入请求队列中。</li><li>请求队列 <strong>通知</strong> 某个工作在同步模式的 <strong>工作线程</strong>，<strong>读取并处理</strong> 该请求对象。</li><li>具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。</li></ul><blockquote><p>半同步&#x2F;半异步模式存在多种变体</p></blockquote><h2 id="领导者-x2F-追随者模式"><a href="#领导者-x2F-追随者模式" class="headerlink" title="领导者&#x2F;追随者模式"></a>领导者&#x2F;追随者模式</h2><p>领导者&#x2F;追随者模式是 <strong>多个工作线程</strong> 轮流获得事件源集合，<strong>轮流监听、分发并处理</strong> 事件的一种模式。在任意时间点，程序都 <strong>仅有一个领导者线程</strong>，它负责监听 I&#x2F;O 事件。而其他线程都是 <strong>追随者</strong>，它们 <strong>休眠</strong> 在线程池中 <strong>等待成为新的领导者</strong>。</p><p>当前的领导者如果检测到 I&#x2F;O 事件，首先要从线程池中 <strong>推选出新的领导者线程</strong>，然后处理 I&#x2F;O 事件。此时，新的领导者等待新的 I&#x2F;O 事件，而原来的领导者则处理 I&#x2F;O 事件，二者实现了并发。</p><p>领导者&#x2F;追随者模式包含如下几个组件：<strong>句柄集</strong>（HandleSet）、<strong>线程集</strong>（ThreadSet）、<strong>事件处理器</strong>（EventHandler）和具体的 <strong>事件处理器</strong>（ConcreteEventHandler）。</p><h3 id="句柄集"><a href="#句柄集" class="headerlink" title="句柄集"></a>句柄集</h3><p>句柄（Handler）用于表示 <strong>I&#x2F;O 资源</strong>，在 Linux 下通常就是一个文件描述符。句柄集管理众多句柄，它使用 wait_for_event 方法来 <strong>监听</strong> 这些句柄上的 <strong>I&#x2F;O事件</strong>，并将其中的 <strong>就绪事件通知给领导者线程</strong>。领导者则调用绑定到 Handler 上的事件处理器来处理事件。领导者将 Handle 和事件处理器绑定是通过调用句柄集中的 register_handler 方法实现的。</p><h3 id="线程集"><a href="#线程集" class="headerlink" title="线程集"></a>线程集</h3><p>这个组件是 <strong>所有工作线程</strong>（包括领导者线程和追随者线程）的 <strong>管理者</strong>。它 <strong>负责</strong> 各线程之间的 <strong>同步</strong>，以及新领导者线程的推选。线程集中的线程在任一时间必处于以下三种状态之一：</p><ul><li><strong>Leader</strong>：线程当前处于领导者身份，负责等待句柄集上的 I&#x2F;O 事件。</li><li><strong>Processing</strong>：线程正在处理事件。领导者检测到 I&#x2F;O 事件之后，可以转移到 Processing 状态来处理该事件，并调用 promote_new_leader 方法推选新的领导者；也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。当处于 Processing 状态的线程处理完事件后，如果当前线程集中没有领导者，则它将成为新的领导者，否则它就直接转变为追随者。</li><li><strong>Follower</strong>：线程当前处于追随者身份，通过调用线程集的 join 方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。</li></ul><p>领导者线程推选新的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员 Synchronizer 来同步这两个操作，以避免竞态条件。</p><h3 id="事件处理器和具体的事件处理器"><a href="#事件处理器和具体的事件处理器" class="headerlink" title="事件处理器和具体的事件处理器"></a>事件处理器和具体的事件处理器</h3><p>事件处理器通常包含 <strong>一个或多个回调函数</strong>（handle_event）。这些回调函数用于处理事件对应的业务逻辑。事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。<strong>具体的事件处理器</strong> 是事件处理器的派生类。它们必须重新实现基类的 handle_event 方法，以处理特定的任务。</p><blockquote><p>由于领导者线程自己监听 I&#x2F;O 事件并处理客户请求，因而领导者&#x2F;追随者模式不需要在线程之间传递任何额外的数据。但领导者&#x2F;追随者的一个明显缺点是仅支持一个事件源集合，因此也 <strong>无法</strong> 让每个工作线程 <strong>独立地管理多个客户连接</strong>。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件处理模式</title>
    <link href="/2022/10/05/%E9%AB%98%E5%B9%B6%E5%8F%91_%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/05/%E9%AB%98%E5%B9%B6%E5%8F%91_%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h1><p><strong>Reactor</strong> 要求 <strong>主线程（I&#x2F;O 处理单元）</strong> 只负责监听文件描述上是否有事件发生，若有，立即将该事件 <strong>通知工作线程</strong>（逻辑单元）。此外，<strong>主线程</strong> 不做任何其他实质性工作。<strong>读写数据，接受新连接，以及处理客户请求</strong> 均在工作线程中完成。</p><p>使用同步 I&#x2F;O 模型（比如 epoll_wait）实现的 Reactor 模式的工作流程是：</p><ol><li><strong>主线程</strong> 往 epoll 内核事件表中注册 socket 上的 <strong>读就绪事件</strong></li><li>主线程调用 epoll_wait <strong>等待</strong> socket 上有 <strong>数据可读</strong></li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程则将 <strong>socket</strong> 可读事件 <strong>放入请求对列</strong>。</li><li>睡眠在请求队列上的某个工作线程被 <strong>唤醒</strong>，它从socket <strong>读取数据</strong>，并 <strong>处理客户请求</strong>，然后往 epoll 内核事件表中 <strong>注册</strong> 该 socket 上的 <strong>写就绪事件</strong>。</li><li>主线程调用 epoll_wait 等待 socket 可写</li><li>当 socket <strong>可写时</strong>，epoll_wait 通知主线程。主线程将 socket <strong>可写事件放入请求队列</strong>。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li></ol><h1 id="Proactor-模式"><a href="#Proactor-模式" class="headerlink" title="Proactor 模式"></a>Proactor 模式</h1><p>与 <strong>Reactor模式</strong> 不同，<strong>Proactor</strong> 模式将所有 <strong>IO操作</strong> 都交给 <strong>主线程和内核</strong> 来处理，<strong>工作线程</strong> 仅负责业务逻辑。</p><p>使用 <strong>异步I&#x2F;O模型</strong>（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p><ol><li><strong>主线程</strong> 调用 aio_read 函数 <strong>向内核注册</strong> socket 上的 <strong>读完成事件</strong>，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。</li><li><strong>主线程</strong> 继续处理其他逻辑。</li><li>当 socket 上的数据 <strong>被读入用户缓冲区</strong> 后，<strong>内核</strong> 将向应用程序发送一个信号，以通知应用程序，数据已经可用。</li><li>应用程序预先定义好的 <strong>信号处理函数</strong>，<strong>选择一个工作线程</strong> 来处理客户请求。工作线程 <strong>处理完客户请求后</strong>，调用 aio_write 函数向内核 <strong>注册</strong> socket 上的 <strong>写完成事件</strong>，并告诉内核用户，写缓冲区的位置，以及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑</li><li>当用户缓冲区的数据 <strong>被写入</strong> socket 之后，内核将向应用程序 <strong>发送</strong> 一个 <strong>信号</strong>，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数，选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li></ol><h1 id="模拟-Proactor-模式"><a href="#模拟-Proactor-模式" class="headerlink" title="模拟 Proactor 模式"></a>模拟 Proactor 模式</h1><p>使用 <strong>同步I&#x2F;O</strong> 方式模拟出 Proactor 模式的一种方法。其原理是：<strong>主线程</strong> 执行数据 <strong>读写操作</strong>，读写完成后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p><p>使用同步 <strong>I&#x2F;O模型</strong>（以epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：</p><ol><li><strong>主线程</strong> 往 <strong>epoll内核事件表</strong> 中注册 socket 上的读就绪事件。</li><li><strong>主线程</strong> 调用 epoll_wait 等待 socket 上有数据可读</li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Reactor 的主线程只监听事件，通知工作线程，IO 操作都由工作线程来完成，Proactor 则相反。</li><li>模拟 Proactor 则是以同步 IO 方式模拟出 Proactor 模式。它的主线程处理 <strong>读写操作</strong>，读写成功后，通知工作线程。而后，工作线程对读写操作的结果进行 <strong>逻辑处理</strong>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO复用</title>
    <link href="/2022/09/27/IO%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/09/27/IO%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h1><blockquote><p><strong>相关术语：</strong></p><ul><li><p>流：可以进行 I&#x2F;O 操作的内核对象，包括文件、管道、套接字。文件描述符（fd）就是流的入口</p></li><li><p>I&#x2F;O操作：<strong>流</strong> 的读写操作。IO 是 input&#x2F;output 的缩写，有时也指代 socket。在 Linux 下，所有的 IO 都统称为 fd。</p></li><li><p>阻塞：<strong>流</strong> 中无数据时，往外读取数据，此时就发生了阻塞（占用 cpu 时间片）。阻塞等待时，不能出来 IO 请求，且，同一个阻塞，同一时刻只能处理一个请求。</p></li><li><p>轮询：不断查询是否可以进行操作。非阻塞忙轮询时，将占用 cpu 时间片，浪费性能</p></li></ul></blockquote><h2 id="为什么使用IO复用"><a href="#为什么使用IO复用" class="headerlink" title="为什么使用IO复用"></a>为什么使用IO复用</h2><p>​        当大量 IO 同时建立连接，随时可能进行操作时，为了在同一时间处理大量的请求（高并发），一个解决方案是，让一个进程处理尽可能多的请求，也就是 <strong>IO 多路复用</strong>。</p><p>​        <strong>多路 IO 复用</strong> 综合了阻塞和轮询的优点，既能阻塞等待，节省资源，也能在同一时刻监听多个 IO 请求的状态。</p><blockquote><p>其它的解决方案，如：阻塞等待 + 多进程&#x2F;线程（开辟线程浪费资源），非阻塞 + 忙轮询（cpu 不断重复判断，利用率低）。</p></blockquote><h2 id="IO多路复用的三种实现"><a href="#IO多路复用的三种实现" class="headerlink" title="IO多路复用的三种实现"></a>IO多路复用的三种实现</h2><h3 id="select（C-标准库函数，跨平台）"><a href="#select（C-标准库函数，跨平台）" class="headerlink" title="select（C 标准库函数，跨平台）"></a>select（C 标准库函数，跨平台）</h3><p>​        select 将轮询每个流，当一个流出现读写操作时，保存起来，待所有的流 <strong>轮询</strong> 完，取出标记的流统一处理。监听的 IO 数量有限，默认 1024 个。且不会标记哪些 IO 是可读可写的，需要遍历。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>大致流程<br><span class="hljs-keyword">while</span> true &#123;<br>select(流[]);<span class="hljs-regexp">//</span>阻塞<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 流[] &#123;<br><span class="hljs-keyword">if</span> i has 数据 &#123;<br>读 或 其他处理<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>​        与 select 类似，poll 同样是进行轮询，并根据 <strong>流的状态</strong> 进行处理，只是 poll 无 <strong>数量的限制</strong>。</p><p>​        poll 与 select 存在一个缺点：它们会将用户态传入的数组拷贝到内核空间，然后逐一查询设备状态。这个过程的开销是线性增大的，连接越多，性能越差。</p><h3 id="epoll（Linux）"><a href="#epoll（Linux）" class="headerlink" title="epoll（Linux）"></a>epoll（Linux）</h3><p>​        epoll 不会轮询每个流，当流出现 IO 操作时，保存起来。epoll 只关心活跃的连接，仅当发现有 IO 操作时，才 <strong>回调</strong> 进行处理。</p><p>​        epoll的机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> &#123;<br>可处理的流<span class="hljs-literal">[]</span> = epoll<span class="hljs-constructor">_wait(<span class="hljs-params">epoll_fd</span>)</span>;<span class="hljs-comment">//阻塞</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 可处理的流<span class="hljs-literal">[]</span> &#123;<br>读 或者 其他处理<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="epoll的触发模式"><a href="#epoll的触发模式" class="headerlink" title="epoll的触发模式"></a>epoll的触发模式</h4><ul><li>EPOLL LT（水平触发），默认模式，只要该fd还有数据可读，每次 <code>epoll_wait</code> 都会返回它的事件，提醒用户程序去操作</li><li>EPOLL ET（边缘触发），高速模式，只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。</li></ul><p>ET模式下，read一个fd时，一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误。</p>]]></content>
    
    
    
    <tags>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu 18.04下安装Nginx</title>
    <link href="/2022/09/07/ubuntu-18-04%E4%B8%8B%E5%AE%89%E8%A3%85nginx/"/>
    <url>/2022/09/07/ubuntu-18-04%E4%B8%8B%E5%AE%89%E8%A3%85nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="安装必要的第三方依赖包"><a href="#安装必要的第三方依赖包" class="headerlink" title="安装必要的第三方依赖包"></a>安装必要的第三方依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get -y install libpcre3 libpcre3-dev<br>sudo apt-get -y install zlib1g-dev<br>sudo apt-get install openssl libssl-dev<br></code></pre></td></tr></table></figure><h2 id="下载Nginx"><a href="#下载Nginx" class="headerlink" title="下载Nginx"></a>下载Nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://nginx.org/download/nginx-1.16.1.tar.gz<br></code></pre></td></tr></table></figure><h2 id="解压，编译"><a href="#解压，编译" class="headerlink" title="解压，编译"></a>解压，编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf nginx-1.16.1.tar.gz<br><span class="hljs-built_in">cd</span> nginx-1.16.1<br>./configure --prefix=/usr/local/nginx<br>make<br>sudo make install<br></code></pre></td></tr></table></figure><blockquote><p>安装后的执⾏⽂件路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</p><p> 配置⽂件路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;</p></blockquote><h2 id="创建配置文件，并在nginx-conf中包含conf-d"><a href="#创建配置文件，并在nginx-conf中包含conf-d" class="headerlink" title="创建配置文件，并在nginx.conf中包含conf.d"></a>创建配置文件，并在nginx.conf中包含conf.d</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建conf⼦⽬录</span><br>sudo <span class="hljs-built_in">mkdir</span> /usr/local/nginx/conf/conf.d<br><span class="hljs-comment"># 修改/usr/local/nginx/conf/nginx.conf</span><br>sudo vim /usr/local/nginx/conf/nginx.conf<br><span class="hljs-comment">#末尾的 &#x27;&#125;&#x27; 前添加，这样在部署即时通讯的⽹⻚配置端时将对应的.conf⽂件拷⻉到 /usr/local/nginx/conf/conf.d⽬录时能够被nginx.conf包含。</span><br>include /usr/local/nginx/conf/conf.d/*.conf;<br><span class="hljs-comment">#将 server &#123;</span><br><span class="hljs-comment">#listen80;</span><br><span class="hljs-comment">#server_namelocalhost;</span><br><span class="hljs-comment"># &#125;</span><br><span class="hljs-comment"># 中的 80 改为 81</span><br><br></code></pre></td></tr></table></figure><h2 id="配置启动Nginx"><a href="#配置启动Nginx" class="headerlink" title="配置启动Nginx"></a>配置启动Nginx</h2><h3 id="1-创建⼀个nginx-service"><a href="#1-创建⼀个nginx-service" class="headerlink" title="1.创建⼀个nginx.service"></a>1.创建⼀个nginx.service</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在 /lib/systemd/system/⽬录下⾯新建⼀个nginx.service⽂件。并赋予可执⾏的权限。</span><br>sudo vim /lib/systemd/system/nginx.service<br></code></pre></td></tr></table></figure><h3 id="2-编辑service内容"><a href="#2-编辑service内容" class="headerlink" title="2.编辑service内容"></a>2.编辑service内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=nginx - high performance web server<br>After=network.target remote-fs.target nss-lookup.target<br>[Install]<br>WantedBy=multi-user.target<br>[Service]<br>Type=forking<br>ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br>ExecReload=/usr/local/nginx/sbin/nginx -s reload<br>ExecStop=/usr/local/nginx/sbin/nginx -s stop<br></code></pre></td></tr></table></figure><h3 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3.启动服务"></a>3.启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在启动服务之前，需要先重载systemctl命令</span><br>sudo systemctl daemon-reload<br><span class="hljs-comment"># 启动nginx</span><br>sudo systemctl start nginx.service<br><br><span class="hljs-comment">#可以使⽤sudo ps -ef | grep nginx 查看是否有相应的进程</span><br></code></pre></td></tr></table></figure><h3 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4.常用命令"></a>4.常用命令</h3><blockquote><p>启动：sudo systemctl start nginx.service<br>停⽌：sudo systemctl stop nginx.service<br>重新加载：sudo systemctl reload nginx.service<br>显示nginx服务的状态：systemctl status nginx.service</p></blockquote><blockquote><p>在开机时启⽤nginx服务：sudo systemctl enable nginx.service<br>在开机时禁⽤nginx服务：sudo systemctl disable nginx.service</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>配置环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql语言-连接</title>
    <link href="/2022/08/31/sql%E8%AF%AD%E8%A8%80-%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/08/31/sql%E8%AF%AD%E8%A8%80-%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="用JOINs进行多表联合查询"><a href="#用JOINs进行多表联合查询" class="headerlink" title="用JOINs进行多表联合查询"></a>用JOINs进行多表联合查询</h2><p>JOINs 可以连接多个表，进行多表联合查询，如：</p><ul><li><strong>SELECT</strong> * <strong>FROM</strong> movies<br><strong>INNER JOIN</strong> Boxoffice <strong>ON</strong> Movies.id &#x3D; Boxoffice.Movie_id<br>&#x2F;&#x2F;连接了Boxoffice表和Movies表，通过 <strong>ON</strong> 条件描述了关联关系，对比了 Movies 表的 id 和 Boxoffice 表的Movie.id</li></ul><p><code>INNER JOIN</code> （内连接）只会保留两个表都存在的数据（交集），一些数据会丢失。</p><p>真实世界中两个表存在差异很正常，所以我们需要更多的连表方式（外连接）。左连接<code>LEFT JOIN</code>，右连接<code>RIGHT JOIN</code> 和全连接<code>FULL JOIN</code>。这几个连接方式都会保留不能匹配的行：</p><table><thead><tr><th align="center">关键字</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">INNER JOIN … ON … &#x3D; …</td><td align="center"><strong>内连接</strong>，通过某个属性连接，<strong>两表</strong> 无对应的数据会舍弃</td></tr><tr><td align="center">LEFT JOIN … ON … &#x3D; …</td><td align="center"><strong>左连接</strong>，通过某个属性连接，<strong>右表</strong> 无对应的数据会舍弃</td></tr><tr><td align="center">RIGTH JOIN … ON … &#x3D; …</td><td align="center"><strong>右连接</strong>，通过某个属性连接，<strong>左表</strong> 无对应的数据会舍弃</td></tr><tr><td align="center">FULL JOIN … ON … &#x3D; …</td><td align="center"><strong>全连接</strong>，通过某个属性连接，<strong>两表</strong> 无对应的数据会 <strong>保留</strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer-矩阵中的路径</title>
    <link href="/2022/08/19/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/08/19/%E5%89%91%E6%8C%87offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><p>难度中等660</p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], word = <span class="hljs-string">&quot;abcd&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board </code>和<code>word</code>仅由大小写英文字母组成</li></ul><p><strong>分析</strong></p><p>可以采用 dfs 深度优先算法（回溯算法，暴力穷举，效率并不高），选定一个数作为起始点，令它上下左右搜索需要的数，上下左右全部不匹配的时候回退；匹配时继续查找下一个数，标记走过的数，匹配完所有需要的数则返回，否则遍历完整个矩阵再终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m,n := <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]),<span class="hljs-built_in">len</span>(board)<br><br>    <span class="hljs-keyword">if</span> n * m &lt; <span class="hljs-built_in">len</span>(word) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-comment">// 终止条件</span><br>        <span class="hljs-keyword">if</span> k &gt;= <span class="hljs-built_in">len</span>(word) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">// 终止条件，遇到边界或者 i j 坐标对应 board 的值不等于 k 坐标对应 word 的值</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= n || j &gt;= m || board[i][j] != word[k] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <br>        &#125;<br>        <span class="hljs-comment">// 如果往回前找，不会找到相同字符，如 ABAB，k = 2 时，往前往后都是 B ；</span><br>        <span class="hljs-comment">// 将 B 修改（剪枝）为不存在的字符，杜绝往回找成功的可能性。</span><br>        board[i][j] = <span class="hljs-string">&#x27;0&#x27;</span><br>        <span class="hljs-comment">//上下左右查找下一个匹配的数</span><br>        res := dfs(i, j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || dfs(i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || dfs(i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || dfs(i - <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 找完了就改回来</span><br>        board[i][j] = word[k]<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++&#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++&#123;<br>            <span class="hljs-keyword">if</span> dfs(i,j,<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="OSI七层模型及功能"><a href="#OSI七层模型及功能" class="headerlink" title="OSI七层模型及功能"></a>OSI七层模型及功能</h2><ul><li><strong>物理层</strong>：底层的数据传输，如网线；网课标准</li><li><strong>数据链路层</strong>：定义数据的基本格式。如何传输、标识等，如：网卡 MAC 地址</li><li><strong>网络层</strong>：定义 IP 编址，路由功能；如：不同设备的数据转发</li><li><strong>传输层：</strong>实现端到端传输数据；如 TCP、UDP传输协议，目的是确保数据包在网络中无损传输</li><li><strong>会话层</strong>：控制应用程序之间的会话。如：不同软件数据分发给不同软件</li><li><strong>表示层</strong>：数据格式标识，基本压缩加密功能</li><li><strong>应用层</strong>：各种应用软件，如：Web 应用</li></ul><blockquote><p><strong>传输层</strong> 数据被称作 <strong>段（Segments）</strong>； </p><p><strong>网络层</strong> 数据被称做 <strong>包（Packages）</strong>； </p><p><strong>数据链路层</strong> 时数据被称为 <strong>帧（Frames）</strong>； </p><p><strong>物理层</strong> 时数据被称为 <strong>比特流（Bits）</strong>。</p></blockquote><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>一次完整的 HTTP 请求过程包括：</p><ul><li>域名解析</li><li>发起 TCP 三次握手，建立连接</li><li>连接后发起 http 请求</li><li>服务器响应 http 请求，浏览器得到 html 代码</li><li>浏览器解析 html 代码，并请求 html 代码中的资源（图片，css，js 等）</li><li>浏览器渲染页面，呈现给用户</li></ul><h2 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h2><p>DNS 即 Domain Name System，域名系统。在因特网上作为一个 <strong>域名和 IP 地址相互映射的分布式数据库</strong>。它能够使用户更方便的访问互联网，而不用记住能被机器直接读取的 IP 数串</p><p><strong>域名解析</strong> 实际上是通过 <strong>主机名</strong>，得到对应的 <strong>IP 地址</strong> 的过程，又叫主机名解析。比如，通过 <a href="http://www.baidu.com/">www.baidu.com</a> （主机名）得到 186.61.200.6</p><h2 id="DNS工作原理"><a href="#DNS工作原理" class="headerlink" title="DNS工作原理"></a>DNS工作原理</h2><p>将 主机域名 转换为 ip地址，属于 <strong>应用层</strong> 协议，使用UDP传输。</p><p><strong>过程：</strong></p><ol><li>当用户 <strong>输入域名</strong>，浏览器检查缓存中是否存在这个域名映射的 <strong>ip地址</strong>，若有，解析结束</li><li>若未命中，检查操作系统缓存（如 Windows 中的 hosts）是否存在对应的解析。若有，解析结束</li><li>若未命中，则 <strong>请求本地域名服务器</strong> 解析（LDNS）</li><li>若 LDNS 也没命中，将跳到 <strong>根域名服务器</strong> 请求解析。根域名服务器返回给 LDNS 一个 主域名服务器地址</li><li>LDNS 再 <strong>发送请求</strong> 给上一步返回的 gTLD（通用顶级域），接受到请求的 gTLD 查找并返回这个域名对应的 Name Server 的地址</li><li>Name Server 根据映射关系表找到目标 ip，返回给 LDNS</li><li>LDNS 缓存这个域名和对应的 ip，把解析的结果返回给用户，用户根据 TTL 值缓存到本地系统缓存中，域名解析过程结束</li></ol><h2 id="域名解析使用为什么要使用UDP"><a href="#域名解析使用为什么要使用UDP" class="headerlink" title="域名解析使用为什么要使用UDP"></a>域名解析使用为什么要使用UDP</h2><p>UDP 的 DNS 协议只需要一个请求和一个响应，速度很快，无需三次握手，四次挥手。虽然 UDP 协议的传输内容不能超过 512 字节，都是域名映射的 IP 通常不会超出 512 字节。</p><h2 id="区域传送为什么要用TCP"><a href="#区域传送为什么要用TCP" class="headerlink" title="区域传送为什么要用TCP"></a>区域传送为什么要用TCP</h2><p>TCP 可靠性更好，区域传送需要从主 DNS 上复制内容，UDP协议传输数据有大小限制，而且不安全，因此选择 TCP 更好。</p><blockquote><p>区域传送：在本域的各个域名服务器之间进行信息的同步</p></blockquote><h2 id="HTTP长连接和短连接的区别"><a href="#HTTP长连接和短连接的区别" class="headerlink" title="HTTP长连接和短连接的区别"></a>HTTP长连接和短连接的区别</h2><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接， 任务结束就中断连接。 </p><ul><li>当浏览器每遇到一个 Web 资源（图片，css，js 等），就会建立一个 HTTP 会话。</li></ul><p>从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。</p><ul><li>使用长连接时，打开网页后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li></ul><blockquote><p>使用长连接的 HTTP 协议，会在响应头加入：Connection: keep-alive</p><p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache ）中设定这个时间。实现长连接要求客户端和服务端都支持长连接</p></blockquote><h2 id="什么是TCP粘包-x2F-拆包？发生的原因？"><a href="#什么是TCP粘包-x2F-拆包？发生的原因？" class="headerlink" title="什么是TCP粘包&#x2F;拆包？发生的原因？"></a>什么是TCP粘包&#x2F;拆包？发生的原因？</h2><p>一个完整的业务可能会被 TCP <strong>拆分成多个包</strong> 进行 <strong>发送</strong>，也有可能把 <strong>多个小的包封装</strong> 成一个 <strong>大的数据包</strong> 发送，这个就是TCP的拆包和粘包问题。</p><p><strong>原因</strong></p><ol><li>应用程序 <strong>写入数据</strong> 的字节大小 <strong>大于</strong> 套接字发送 <strong>缓冲区</strong> 的大小. </li><li>进行MSS大小的TCP分段。( MSS&#x3D;TCP报文段长度-TCP首部长度) </li><li>以太网的 payload 大于 MTU 进行 IP 分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）</li></ol><p><strong>解决方案</strong></p><ol><li>消息定长。</li><li>在包尾部增加回车或者空格符等特殊字符进行分割</li><li>将消息分为消息头和消息尾。</li><li>使用其它复杂的协议，如RTMP协议等。</li></ol><h2 id="为什么服务器要缓存-如何实现？"><a href="#为什么服务器要缓存-如何实现？" class="headerlink" title="为什么服务器要缓存?如何实现？"></a>为什么服务器要缓存?如何实现？</h2><p><strong>原因</strong></p><ul><li><p>缓解服务器压力；</p></li><li><p>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</p></li></ul><p><strong>实现方法</strong></p><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。<br>根据 HTTP 标准，HTTP 请求可以使用多种 <strong>请求方法</strong>。<br>HTTP1.0 定义了三种请求方法： <strong>GET, POST 和 HEAD</strong> 方法。<br>HTTP1.1 <strong>新增</strong> 了六种请求方法：<strong>OPTIONS</strong>、<strong>PUT</strong>、<strong>PATCH</strong>、<strong>DELETE</strong>、<strong>TRACE</strong> 和 <strong>CONNECT</strong> 方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的 <strong>响应中没有具体的内容</strong>，用于 <strong>获取报头</strong></td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含 在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td></tr><tr><td>PUT</td><td>客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1 协议中预留给能够将连接改为 <strong>管道方式</strong> 的 <strong>代理服务器</strong>。</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><ol><li>get 获取数据，post 修改数据</li><li>get把请求的数据放在 url 上， 以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连，所以 get 不太安全。而post 把数据放在 HTTP 的包体内（requrest body）</li><li>get 提交的数据最大是 2k（ 限制取决于浏览器）， post 理论上没有限制</li><li>GET 产生 <strong>一个</strong> TCP 数据包，浏览器会把 http header 和 data 一并发送出去，服务器响应 200(返回数据);  POST产生 <strong>两个</strong> TCP 数据包，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应200 ok(返回数据)</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置</li><li>本质区别：GET 是幂等的，而 POST 不是幂等的（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说，对同一 URL 的 <strong>多个请求应该返回同样的结果</strong>）</li></ol><blockquote><p>因此，不应该且不能用 get 请求做数据的 <strong>增删改</strong> 这些有副作用的操作。因为 get 请求是幂等的，在网络不好的隧道中会尝试重试。如果用 get 请求增数据，会有重复操作的风险，而这种重复操作可能会导致别的问题（浏览器和操作系统并不知道你会用get请求去做增操作）。</p></blockquote><h2 id="一个TCP连接可以对应几个HTTP请求"><a href="#一个TCP连接可以对应几个HTTP请求" class="headerlink" title="一个TCP连接可以对应几个HTTP请求"></a>一个TCP连接可以对应几个HTTP请求</h2><p>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。</p><h2 id="一个TCP连接中HTTP请求发送可以一起发送吗？"><a href="#一个TCP连接中HTTP请求发送可以一起发送吗？" class="headerlink" title="一个TCP连接中HTTP请求发送可以一起发送吗？"></a>一个TCP连接中HTTP请求发送可以一起发送吗？</h2><p>HTTP&#x2F;1.0 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求。两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。</p><p>HTTP&#x2F;1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是浏览器默认关闭。在 HTTP2 中由于Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</p><p>在 HTTP&#x2F;1.1 时代，浏览器是提高页面加载效率，主要有下面两点：</p><ul><li><strong>维持</strong> 和服务器已经建立的 <strong>TCP 连接</strong>，在同一连接上顺序处理多个请求。</li><li>和服务器 <strong>建立多个 TCP 连接</strong>。</li></ul><h2 id="浏览器对同一Host建立TCP连接到的数量有没有限制？"><a href="#浏览器对同一Host建立TCP连接到的数量有没有限制？" class="headerlink" title="浏览器对同一Host建立TCP连接到的数量有没有限制？"></a>浏览器对同一Host建立TCP连接到的数量有没有限制？</h2><p>假设我们还处在 HTTP&#x2F;1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一<br>个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000<br>个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p><p>那么浏览器是怎么做的呢？</p><p>以谷歌浏览器为例，Chrome 最多允许对同一个 Host 建立六个 TCP 连接。（不同的浏览器有一些区别）：</p><ul><li><p>如果图片 <strong>都是 HTTPS 连接</strong> 并且 <strong>在同一个域名下</strong>，那么浏览器在 SSL 握手之后会和服务器商量能不能用HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。</p></li><li><p>如果不能使用 HTTP2，或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP&#x2F;1.1）。浏览器将会在一个 HOST 上 <strong>建立多个 TCP 连接</strong>，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p></li></ul><h2 id="在浏览器中输入url地址后显示主页的过程"><a href="#在浏览器中输入url地址后显示主页的过程" class="headerlink" title="在浏览器中输入url地址后显示主页的过程"></a>在浏览器中输入url地址后显示主页的过程</h2><ul><li>根据域名，进行 DNS 域名解析</li><li>拿到解析的 IP 地址，建立 TCP 连接；</li><li>向 IP 地址发送 HTTP 请求</li><li>服务器处理请求</li><li>返回响应结果</li><li>关闭 TCP 连接</li><li>浏览器解析 HTML</li><li>浏览器渲染网页</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer-用两个栈实现队列</title>
    <link href="/2022/08/16/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/08/16/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><p>​        用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>栈为先进后出，队列为先进先出，用两个栈，可以在插入元素后，将栈 1 中的元素反转加入栈 2 ，这样，栈 2 的弹出顺序，相比于栈 1，即是 “先进先出”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.AppendTail(value);</span><br><span class="hljs-comment"> * param_2 := obj.DeleteHead();</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">type</span> CQueue <span class="hljs-keyword">struct</span> &#123;<br>    stack1, stack2 *list.List<span class="hljs-comment">//list包的List函数，是一个结构体 </span><br>&#125;<br><br><span class="hljs-comment">//创建</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> CQueue &#123;<br>    <span class="hljs-keyword">return</span> CQueue&#123;<br>        stack1: list.New(),<br>        stack2: list.New(),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CQueue)</span></span> AppendTail(value <span class="hljs-type">int</span>)  &#123;<br>    this.stack1.PushBack(value)<span class="hljs-comment">//元素直接加入 stack1 的尾部即可</span><br>    <span class="hljs-comment">//若依次插入 10 20 30，存储后，stacke1 从上到下的顺序为 10 20 30</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *CQueue)</span></span> DeleteHead() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//若 stack2 为空，把 stack1 的元素倒置放入 stack2，并清空 stack1</span><br>    <span class="hljs-keyword">if</span> this.stack2.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">for</span> this.stack1.Len() &gt; <span class="hljs-number">0</span> &#123;<br>            this.stack2.PushBack(this.stack1.Remove(this.stack1.Back()))<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//stack2 不为空就</span><br>    <span class="hljs-keyword">if</span> this.stack2.Len() != <span class="hljs-number">0</span> &#123;<br>        e := this.stack2.Back() <span class="hljs-comment">//返回 stack2 的最后一个元素，即队列的头</span><br>        this.stack2.Remove(e)<span class="hljs-comment">//删除</span><br>        <span class="hljs-keyword">return</span> e.Value.(<span class="hljs-type">int</span>)<span class="hljs-comment">//使用类型断言转为 int</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer-重建二叉树</title>
    <link href="/2022/08/16/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/08/16/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="18、重建二叉树"><a href="#18、重建二叉树" class="headerlink" title="18、重建二叉树"></a>18、重建二叉树</h2><p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p><p><strong>注意</strong>:</p><ul><li>二叉树中每个节点的值都互不相同；</li><li>输入的前序遍历和中序遍历一定合法；</li></ul><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>树中节点数量范围 [0,100]。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定：<br>前序遍历是：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>]<br>中序遍历是：[<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>]<br><br>返回：[<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>]<br>返回的二叉树如下所示：<br>    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>根据二叉树先序遍历和中序遍历的定义，前序遍历第一个数为 <strong>根节点</strong>（样例中的 3）。</p><p>中序遍历中，该根节点对应的数的左边为 <strong>左子树</strong>（样例中的 9），右边为 <strong>右子树</strong>（样例中的 15 20 7）。</p><p>结合左子树在先序遍历数列中的顺序，即可确定一棵二叉树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> inorder &#123;<br>        <span class="hljs-comment">//数字互不相同，可以这样</span><br>        <span class="hljs-comment">//当找到先序遍历和中序遍历中相同的数字，就可以确定，当前数在树中的</span><br><span class="hljs-keyword">if</span> inorder[k] == preorder[<span class="hljs-number">0</span>] &#123;<span class="hljs-comment">//中序遍历 root (index=k)</span><br><span class="hljs-keyword">return</span> &amp;TreeNode&#123;<br>Val: preorder[<span class="hljs-number">0</span>],<br><span class="hljs-comment">//Val: inorder[k],</span><br>Left:  buildTree(preorder[<span class="hljs-number">1</span>:k+<span class="hljs-number">1</span>], inorder[<span class="hljs-number">0</span>:k]),<br>Right: buildTree(preorder[k+<span class="hljs-number">1</span>:], inorder[k+<span class="hljs-number">1</span>:]),<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之跳表</title>
    <link href="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B7%B3%E8%A1%A8/"/>
    <url>/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​        跳表（SkipList）是在一个<code>有序的链表</code>上面建立索引，类似于在链表中使用二分查找，实现快速查找、插入、删除。redis 中的 zset 就是跳表。跳表的时间复杂度是 O(logN)，空间复杂度是 O(N)</p><p><img src="https://img-blog.csdnimg.cn/20190711104107346.png" alt="网图"></p><h2 id="跳表的结构"><a href="#跳表的结构" class="headerlink" title="跳表的结构"></a>跳表的结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SkipListLevel <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//指向下一个结点</span><br>forward *SkipListNode<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 到下一个node的距离;</span><br><span class="hljs-comment"> */</span><br>span <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> SkipListNode <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//指向上一个结点</span><br>backward *SkipListNode<br><span class="hljs-comment">//索引用的层</span><br>level []SkipListLevel<br><span class="hljs-comment">//存储的值</span><br>value ISkipListNode<br><span class="hljs-comment">//排名用的分数</span><br>score <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> SkipList <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//头结点和尾结点</span><br><span class="hljs-comment">//头结点是一个真实存在的,尾结点只是一个指针</span><br>head, tail *SkipListNode<br><br>size <span class="hljs-type">int64</span> <span class="hljs-comment">//node总数</span><br><br>level <span class="hljs-type">int</span> <span class="hljs-comment">//当前跳表的最高level</span><br><br>maxLevel <span class="hljs-type">int</span> <span class="hljs-comment">//当前最大层数，跳表可达的最大高度</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gorm 入门实践</title>
    <link href="/2022/07/23/gorm-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <url>/2022/07/23/gorm-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<p>项目中导入 gorm：</p><p><code>go get -u github.com/jinzhu/gorm</code></p><h1 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h1><p>核心代码：<code>gorm.Open(&quot;mysql&quot;,&quot;user:password@(localhost)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/jinzhu/gorm&quot;</span><br>_ <span class="hljs-string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span> <span class="hljs-comment">//需获取驱动（go get -u github.com/jinzhu/gorm/dialects/mysql）</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    db, err := gorm.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;user:password@(localhost:3306)/dbname? +</span><br><span class="hljs-string">                         &quot;</span>charset=utf8mb4&amp;parseTime=True&amp;loc=Local<span class="hljs-string">&quot;)</span><br><span class="hljs-string">                         //可以自动建表，不能自动建数据库</span><br><span class="hljs-string"> defer db.Close()</span><br><span class="hljs-string"> &#125;</span><br></code></pre></td></tr></table></figure><h1 id="GORM-操作-MySQL"><a href="#GORM-操作-MySQL" class="headerlink" title="GORM 操作 MySQL"></a>GORM 操作 MySQL</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/jinzhu/gorm&quot;</span><br>_ <span class="hljs-string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> UserInfo <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-type">int</span><br>Name   <span class="hljs-type">string</span><br>Gender <span class="hljs-type">string</span><br>Hobby  <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;try open mysql connection....&quot;</span>)<br>db, err := gorm.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;root:root@(localhost:3306)/gorm?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;connect is failed&quot;</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> db.Close() <span class="hljs-comment">//自动关闭数据库</span><br><span class="hljs-comment">//自动迁移 schema，若该表不存在，则创建表，若存在，发生变化时更新表</span><br>db.AutoMigrate(&amp;UserInfo&#123;&#125;)<br><br>u1 := UserInfo&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;篮球&quot;</span>&#125;<br><span class="hljs-comment">//创建</span><br>db.Create(&amp;u1)<br>db.Create(&amp;u2)<br><span class="hljs-comment">//查询</span><br><span class="hljs-keyword">var</span> u = <span class="hljs-built_in">new</span>(UserInfo)<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, u)<br><br><span class="hljs-keyword">var</span> uu UserInfo<br>db.Find(&amp;uu, <span class="hljs-string">&quot;hobby=?&quot;</span>, <span class="hljs-string">&quot;篮球&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, uu)<br><span class="hljs-comment">//更新</span><br>db.Model(&amp;u).Update(<span class="hljs-string">&quot;hobby&quot;</span>, <span class="hljs-string">&quot;双色球&quot;</span>)<br><span class="hljs-comment">//删除</span><br>    db.Delete(&amp;u)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​        使⽤ORM⼯具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进⾏映射。模型是标准的 struct，由 Go 的基本数据类型、实现了 <a href="https://pkg.go.dev/database/sql/?tab=doc#Scanner">Scanner</a> 和 <a href="https://pkg.go.dev/database/sql/driver#Valuer">Valuer</a> 接口的自定义类型及其指针或别名组成。</p><p>​        结构体中，名为ID 的字段会默认作为主键。</p><h3 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gorm.Model 的定义</span><br><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;<br>  ID        <span class="hljs-type">uint</span>           <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><span class="hljs-comment">//结构体标记（tags），这里指定了主键</span><br>  CreatedAt time.Time<br>  UpdatedAt time.Time<br>  DeletedAt gorm.DeletedAt <span class="hljs-string">`gorm:&quot;index&quot;`</span><span class="hljs-comment">//创建具有或不带名称的索引，如果多个索引同名，则创建复合索引</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​        gorm 支持的 tags有许多，详情可以去官方文档查看</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang中channel、WaitGroup及select的使用</title>
    <link href="/2022/07/10/golang%E4%B8%ADchannel%E3%80%81WaitGroup%E5%8F%8Aselect%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/10/golang%E4%B8%ADchannel%E3%80%81WaitGroup%E5%8F%8Aselect%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>​        如果说 goroutine 是 Go 语言程序的并发体的话，那么 channels 它们之间的 <strong>通信机制</strong>。</p><ul><li>作为协程的 <strong>输出</strong>，通道是一个容器，它可以容纳数据。</li><li>作为协程的 <strong>输入</strong>，通道是一个生产者，它可以向协程提供数据。</li><li>通道作为容器是有 <strong>限定大小</strong> 的，满了就写不进去，空了就读不出来。</li><li>通道有它自己的类型，它可以 <strong>限定</strong> 进入通道的 <strong>数据的类型</strong>。</li></ul><h1 id="创建-channel"><a href="#创建-channel" class="headerlink" title="创建 channel"></a>创建 channel</h1><p>创建 channel 需要使用 make 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//int 可以替换成其他类型，这里指定了容量为 1024 属于缓冲型通道 </span><br><span class="hljs-keyword">var</span> bufferedChannel = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1024</span>) <br><span class="hljs-comment">//非缓冲型通道：</span><br><span class="hljs-keyword">var</span> unbufferedChannel = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-comment">//两个相同类型的channel可以使用==运算符比较。</span><br><span class="hljs-comment">//如果两个channel引用的是相通的对象，那么比较的结果为真。</span><br><span class="hljs-comment">//一个channel也可以和nil进行比较</span><br></code></pre></td></tr></table></figure><h1 id="读写-channel"><a href="#读写-channel" class="headerlink" title="读写 channel"></a>读写 channel</h1><p>​        Go 语言为通道的读写设计了特殊的箭头语法糖 &lt;-，让我们使用通道时非常方便。把箭头写在通道变量的右边就是 <strong>写通道（ch&lt;-）</strong>，把箭头写在通道的左边就是 <strong>读通道（&lt;-ch）</strong>。一次只能读写一个元素。</p><p>​        可以使用 <strong>cap()</strong> 和 <strong>len()</strong> 全局函数获得通道的容量和当前内 部的元素个数。</p><h1 id="读写阻塞"><a href="#读写阻塞" class="headerlink" title="读写阻塞"></a>读写阻塞</h1><p>​        通道满了时，写操作就会 <strong>阻塞</strong>，协程就会进入休眠，直到有其它协程读通道挪出了空间，协程才会被唤醒。如果有多个协程的写操作都阻塞了，一个读操作只会唤醒一个协程。</p><p>​        <strong>非缓冲通道</strong> 只能写入一个数据，当其内有数据时，写操作陷入 <strong>阻塞</strong>；反之，无数据时，读操作陷入 <strong>阻塞</strong>。</p><h1 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h1><ul><li><p>使用 close（channel），关闭通道</p></li><li><p><strong>读</strong> 一个已经关闭的通道会立即返回通道 对应 <strong>类型的「零值」</strong></p></li><li><p><strong>写</strong>一个已经关闭的通道会 <strong>抛异常</strong>。</p></li><li><p>如果通道里的元素是整型的，读操作是不能通过返回值来确定通道是否关闭的。</p></li></ul><h1 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h1><p>WaitGroup 用于等待一组 goroutines 完成相关的任务，可以以此控制多次写入的顺序。主 goroutine 被阻塞，直到所有 goroutine 执行完成。</p><p>WaitGroup 可以用于做任务编排的并发原语。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(waitgroup *sync.WaitGroup)</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Inside my goroutine&quot;</span>)<br>   <span class="hljs-comment">//表示已完成</span><br>   waitgroup.Done()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br><br>   <span class="hljs-keyword">var</span> waitgroup sync.WaitGroup<br>   <span class="hljs-comment">//设置需要等待的goroutine数量</span><br>   waitgroup.Add(<span class="hljs-number">1</span>)<br>   <span class="hljs-comment">//创建子goroutine完成设定的任务</span><br>   <span class="hljs-keyword">go</span> myFunc(&amp;waitgroup)<br><br>   <span class="hljs-comment">//此时main函数所在的goroutine阻塞在Wait(), 等待Done函数执行</span><br>   waitgroup.Wait()<br>   fmt.Println(<span class="hljs-string">&quot;finish&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>WaitGroup 提供了三个方法：</p><ul><li>func (wg *WaitGroup) Add(delta int)。设置WaitGroup的计数值</li><li>func (wg *WaitGroup) Done()。用来将WaitGroup的计数值减1，其实就是调用了Add(-1)</li><li>func (wg *WaitGroup) Wait()。调用这个方法的goroutine会一直阻塞，直到WaitGroup的计数值变为0。</li></ul><h1 id="多路复用-select"><a href="#多路复用-select" class="headerlink" title="多路复用 select"></a>多路复用 select</h1><blockquote><p>​        设想这样一个场景：有多个消费来源，只要有一个来源生产了数据，消费者就可以读这个数据进行消费。</p><p>​        这时候可以将多个来源通道的数据汇聚到目标通道，然后统一在目标通道进行消费。</p></blockquote><p>​        GO 语言中，使用select 可以监听 channel 上的数据流动，控制多个 channel。select 默认是阻塞的，只有当监听的 channel 中有发送或接收可以进行时才会运行，当多个 channel 都准备好的时候，select 是随机的选择一个执行的。</p><p>select 类似 switch ，也有 default，当监听的 channel 都没有准备好的时候，默认执行 default（select不再阻塞等待channel）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(c, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>x, y := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> c &lt;- x:<br>x, y = y, x+y<br>         <span class="hljs-comment">//当quit管道有数据时执行</span><br><span class="hljs-keyword">case</span> &lt;-quit:<br>fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br><span class="hljs-keyword">return</span><br>         <span class="hljs-comment">//如果5秒还没执行完，则超时，退出select，程序继续</span><br>         <span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">5</span> * time.Second):<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timeout&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(&lt;-c)<br>&#125;<br>quit &lt;- <span class="hljs-number">0</span><br>&#125;()<br>fibonacci(c, quit)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实现非阻塞读写"><a href="#实现非阻塞读写" class="headerlink" title="实现非阻塞读写"></a>实现非阻塞读写</h1><p>​        通道的非阻塞读写要求：当通道空时，读操作不会阻塞；当通道满时，写操作也不会阻塞。</p><p>​        非阻塞读写需要依靠 select 语句的 <strong>default 分支</strong>。当 select 语句所有通道都不可读写时，如果定义了 default 分支，那就会执行 default 分支逻辑，这样就起到了不阻塞的效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, ch2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        i++<br>        <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> ch1 &lt;- i:<br>            fmt.Printf(<span class="hljs-string">&quot;send ch1 %d\n&quot;</span>, i)<br>            <span class="hljs-keyword">case</span> ch2 &lt;- i:<br>            fmt.Println(<span class="hljs-string">&quot;send ch2 %d\n&quot;</span>, i)<br>            <span class="hljs-keyword">default</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;ch block\n&quot;</span>)<br>            <span class="hljs-comment">// 分支逻辑</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B 树和 B+ 树</title>
    <link href="/2022/07/09/B%E6%A0%91%E5%92%8CB+%E6%A0%91/"/>
    <url>/2022/07/09/B%E6%A0%91%E5%92%8CB+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h1><ul><li>每个结点至多拥有 M 颗子树</li><li><strong>根结点</strong> 至少拥有两颗子树</li><li>除了根结点外，其余每个分支结点，至少拥有 <strong>M&#x2F;2 颗子树</strong></li><li>所有的 <strong>叶节点</strong> 都在 <strong>同一层</strong> 上</li><li>有 k 颗子树的 <strong>分支结点</strong> 则存在 <strong>k-1 个关键字</strong>，关键字按递增顺序排序</li><li>关键字数量满足 ceil (M&#x2F;2)- 1&lt;&#x3D; n &lt;&#x3D; M - 1</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 中的异常处理</title>
    <link href="/2022/07/09/golang%20%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/07/09/golang%20%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>​    Go 语言使用关键字 <strong>go</strong> 把函数放到协程中运行，每一个 go 开启一个协程。</p><p>​    在 Go 语言中，如果某一个协程 <strong>异常退出</strong>，如果不做处理，会导致整个进程的退出（子协程的异常退出也会影响主协程，导致程序崩溃 ）。</p></blockquote><h1 id="使用-recover-处理异常"><a href="#使用-recover-处理异常" class="headerlink" title="使用 recover 处理异常"></a>使用 recover 处理异常</h1><blockquote><p>在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过 try&#x2F;catch 机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。</p><p>Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常，recover 的宕机恢复机制就对应其他语言中的 try&#x2F;catch 机制。</p><p>有 panic 也有 recover 的情况下程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</p></blockquote><p><strong>recover</strong> 是一个Go语言的 <strong>内建函数</strong>，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅延迟函数 <strong>defer</strong> 中有效。 </p><p>如果当前的 goroutine 陷入恐慌（panic），调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">//处理panic</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;执行 defer：&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;捕获 error：&quot;</span>, err)<br>&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;run in grand grand child goroutine&quot;</span>)<br><span class="hljs-keyword">var</span> ptr *<span class="hljs-type">int</span><br>*ptr = <span class="hljs-number">0x12345</span> <span class="hljs-comment">//主动制造崩溃</span><br>&#125;()<br>    time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;程序继续执行&quot;</span>)<span class="hljs-comment">//如果程序没有崩溃，打印出这段话</span><br>&#125;<br><span class="hljs-comment">/* 输出</span><br><span class="hljs-comment">run in grand grand child goroutine</span><br><span class="hljs-comment">执行 defer：                                                                 </span><br><span class="hljs-comment">捕获 error： runtime error: invalid memory address or nil pointer dereference</span><br><span class="hljs-comment">程序继续执行</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2022/07/07/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/07/07/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><ul><li>每个结点都是 <strong>红的</strong> 或者 <strong>黑的</strong></li><li>根节点是黑色的</li><li>每个叶子结点是黑的</li><li>如果一个结点是 <strong>红色</strong> 的，则它的 <strong>两个儿子都是黑的</strong>（红色结点不相邻）。</li><li>对于每个结点，从该结点到其子孙结点的所有路径上包含 <strong>相同数目的黑结点</strong>（以黑结点的数量作为高度）。</li></ul><h2 id="代码实现一棵极简红黑树"><a href="#代码实现一棵极简红黑树" class="headerlink" title="代码实现一棵极简红黑树"></a>代码实现一棵极简红黑树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RED0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLACK 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_rtree_node</span>&#123;<br><span class="hljs-type">int</span> key;<br>    <span class="hljs-type">void</span> *value;<br>    <span class="hljs-comment">//符合以下定义即为红黑树</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_rtree_node</span> *right;<span class="hljs-comment">//当前结点的右子树</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_rtree_node</span> *left;<span class="hljs-comment">//当前结点的左子树</span><br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_rtree_node</span> *parent;<span class="hljs-comment">//当前结点的父结点</span><br>    <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> color;<span class="hljs-comment">//红黑树的颜色</span><br>      <br>&#125; rbtree_node;<span class="hljs-comment">//红黑树的结点</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_rbtree</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_rtree_node</span> *root;<span class="hljs-comment">//根节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_rtree_node</span> *nil;<span class="hljs-comment">//叶子结点</span><br>&#125;rtree;<span class="hljs-comment">//红黑树</span><br></code></pre></td></tr></table></figure><h2 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h2><ul><li>当红黑树的性质被破坏时，对红黑树进行维护（旋转、变色）</li><li>旋转可以分为左旋和右旋</li></ul><blockquote><p>借用朋友博客的图：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/f7026e4bf971492e92acbcbb6e7c2772.png" alt="左旋和右旋"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//左旋</span><br><span class="hljs-comment">//注意，需要判断 x 是否是根结点，y 是不是叶子结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rbtree_left_rotate</span><span class="hljs-params">(rbtree *T, rbtree_node *x)</span></span>&#123;<br>    rbtree_node *y = x-&gt;right;<span class="hljs-comment">//设置 y 指向 x 的右子树</span><br>    x-&gt;right = y-&gt;left;<span class="hljs-comment">//设置 x 的右子树为 y 的左子树（即上图中的 b）</span><br>    <span class="hljs-keyword">if</span> (y-&gt;left != T-&gt;nil)&#123;<br>    y-&gt;left-&gt;parent = x;<span class="hljs-comment">//令 y 的左子树(b)的父节点指向 x,前提是 y 不是叶子结点</span><br>    &#125;<br>    <br>    y-&gt;parent = x-&gt;parent;<span class="hljs-comment">//令 y 的父节点指向 x 的父节点</span><br>    <br>    <span class="hljs-keyword">if</span> (x-&gt;parent == T-&gt;nil)&#123;<span class="hljs-comment">//若 x 的父节点为空（x为根结点）</span><br>        T-&gt;root = y;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == x-&gt;parent-&gt;left)&#123; <span class="hljs-comment">//判断 x 是其父节点的左子树还是右子树</span><br>        x-&gt;parent-&gt;left = y;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        x-&gt;parent-&gt;right = y;<br>    &#125;<br>    <span class="hljs-comment">//最后，更改 y 的左子树和 x 的父节点</span><br>    y-&gt;left = x;<br>    x-&gt;parent = y;<br>&#125;<br><span class="hljs-comment">//右旋</span><br><span class="hljs-comment">//x改成y，y改成x；left改成right，right改成left</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rbtree_left_rotate</span><span class="hljs-params">(rbtree *T, rbtree_node *y)</span></span>&#123;<br>    rbtree_node *x = y-&gt;left;<br><br>y-&gt;left = x-&gt;right;<br><span class="hljs-keyword">if</span> (x-&gt;right != T-&gt;nil) &#123;<br>x-&gt;right-&gt;parent = y;<br>&#125;<br><br>x-&gt;parent = y-&gt;parent;<br><span class="hljs-keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;<br>T-&gt;root = x;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == y-&gt;parent-&gt;right) &#123;<br>y-&gt;parent-&gt;right = x;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>y-&gt;parent-&gt;left = x;<br>&#125;<br><br>x-&gt;right = y;<br>y-&gt;parent = x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>​        插入结点与二叉树类似，但新增结点后，需要上色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rbtree_insert</span><span class="hljs-params">(rbtree *T, rbtree_node *z)</span> </span>&#123;<br>    rbtree_node *y = T-&gt;nil;<br>    rbtree_node *x = T-&gt;root;<br>    <span class="hljs-comment">//若 x 是叶子结点，跳过</span><br>    <span class="hljs-comment">//若 x 不是叶子结点，寻找可以插入的结点（红色结点）</span><br>    <span class="hljs-keyword">while</span> (x != T-&gt;nil)&#123;<br>        y = x;<br>        <span class="hljs-keyword">if</span> (z-&gt;key &lt; x-&gt;key)&#123;<br>            x = x-&gt;left;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z-&gt;key &gt; x-&gt;key)&#123;<br>            x = x-&gt;right;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (y == T-&gt;nil) &#123;<span class="hljs-comment">//若y指向的是空结点</span><br>        T-&gt;root = z;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <br>        <span class="hljs-keyword">if</span> (y-&gt;key &gt; z-key) &#123;<br>            y-&gt;left = z;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            y-&gt;right = z;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//插入结点</span><br>    z-&gt;parent = y;<br>    <br>    z-&gt;left = T-&gt;nil;<br>    z-&gt;right = T-&gt;nil;<br>    z-&gt;color = RED;<span class="hljs-comment">//设置为红色</span><br>&#125;<br></code></pre></td></tr></table></figure><p>插入结点后，为维护红黑树的性质，需要追踪到插入后的结点 z 的祖父结点与叔父结点，根据它们颜色的不同，可分为以下几种情况：<a href="https://www.bilibili.com/video/BV1nf4y1z7nP?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=fb5dbc5ba5faddd22ea8c9063a4ba77/">参考视频</a></p><ol><li>父节点是祖父结点的左子树<ul><li>叔父节点是红色。此时，祖父节点必为黑色，这种情况，将祖父结点置为红色，父节点，叔父结点皆置黑。</li><li>叔父节点是黑色。且当前结点是右孩子时</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rbtree_insert_fixup</span><span class="hljs-params">(rbtree *T, rbtree_node *z)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(z-&gt;parent-&gt;color == RED) &#123;<span class="hljs-comment">//若父节点是红色的</span><br>        <br>        <span class="hljs-keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;<span class="hljs-comment">//如果父结点是祖父结点的左子树</span><br>            rbtree_node *y = z-&gt;parent-&gt;right;<br>            <br>            <span class="hljs-keyword">if</span> (y-&gt;color == RED) &#123;<span class="hljs-comment">//若叔父结点是红色的</span><br>                z-&gt;parent-&gt;color = BLACK;<span class="hljs-comment">//父节点置黑</span><br>                y-&gt;color = BLACK;<span class="hljs-comment">//叔父结点置黑</span><br>                z-&gt;parent-&gt;parent-&gt;color = RED;<span class="hljs-comment">//祖父结点置红</span><br>                <br>                z = z-&gt;parent-&gt;parent;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//叔父结点是黑色时</span><br>                <br>                <span class="hljs-keyword">if</span> (z)<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 实现归并排序</title>
    <link href="/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>基本思想：最小分组比较，依次合并</p><ol><li>创建一个大集合，长度为两个小集合之和</li><li>从左到右逐一比较两个小集合中的元素，把较小的优先放入大集合</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> arr<br>&#125;<br>i := <span class="hljs-built_in">len</span>(arr) / <span class="hljs-number">2</span><br>left := MergeSort(arr[<span class="hljs-number">0</span>:i])<br>right := MergeSort(arr[i:])<br><br><br>result := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>m, n := <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-comment">// left和right的index位置</span><br>l, r := <span class="hljs-built_in">len</span>(left), <span class="hljs-built_in">len</span>(right)<br><span class="hljs-keyword">for</span> m &lt; l &amp;&amp; n &lt; r &#123;<br><span class="hljs-keyword">if</span> left[m] &gt; right[n] &#123;<br>result = <span class="hljs-built_in">append</span>(result, right[n])<br>n++<br><span class="hljs-keyword">continue</span><br>&#125;<br>result = <span class="hljs-built_in">append</span>(result, left[m])<br>m++<br>&#125;<br>result = <span class="hljs-built_in">append</span>(result, right[n:]...)<br>result = <span class="hljs-built_in">append</span>(result, left[m:]...)<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 实现基数排序</title>
    <link href="/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>基数排序又称桶排序，是一种稳定的排序。它分为 <strong>最高位优先(Most Significant Digit first)法</strong> 和 <strong>最低位优先(Least Significant Digit first)法</strong>。</p><p>以LSD为例，假设原来有一串数值如下所示：</p><p>73, 22, 93, 43, 55, 14, 28, 65, 39, 81, 12</p><p><strong>首先</strong> 根据 <strong>个位数</strong> 的数值，在走访数值时将它们分配至编号0到9的桶子中：</p><p>0</p><p>1 81</p><p>2 22 12</p><p>3 73 93 43</p><p>4 14</p><p>5 55 65</p><p>6</p><p>7</p><p>8 28</p><p>9 39</p><p><strong>然后</strong> 把桶中的数值拼接起来，变成：</p><p>81, 22, 12, 73, 93, 43, 14, 55, 65, 28, 39</p><p>再根据十位数分配：</p><p>0</p><p>1 12 14</p><p>2 22 28</p><p>3 39</p><p>4 43</p><p>5 55</p><p>6 65</p><p>7 73</p><p>8 81</p><p>9 93</p><p><strong>再一次</strong> 拼接起来：12, 14, 22, 28, 39, 43, 55, 65, 73, 81, 93 。此时数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。</p><p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(array []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">//1.找到最小值和最大值</span><br>min, max := <span class="hljs-number">1000000</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> array &#123;<br><span class="hljs-keyword">if</span> v &gt; max &#123;<br>max = v<br>&#125;<br><span class="hljs-keyword">if</span> v &lt; min &#123;<br>min = v<br>&#125;<br>&#125;<br><span class="hljs-comment">//2.初始化桶</span><br>bucketNum := (max-min)/<span class="hljs-built_in">len</span>(array) + <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> bucketList [][]<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; bucketNum; i++ &#123;<br>bucketItem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>bucketList = <span class="hljs-built_in">append</span>(bucketList, bucketItem)<br>&#125;<br><span class="hljs-comment">//3.把元素放到桶内</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> array &#123;<br>number := (v - min) / <span class="hljs-built_in">len</span>(array)<br>bucketList[number] = <span class="hljs-built_in">append</span>(bucketList[number], v)<br>&#125;<br><span class="hljs-comment">//4.桶内进行排序</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> bucketList &#123;<br>sort.Ints(v)<br>&#125;<br><span class="hljs-comment">///5.依次输出</span><br>index := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> bucketList &#123;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> v &#123;<br>array[index] = m<br>index++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//来自https://juejin.cn/post/7066728890575618078</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 实现希尔排序</title>
    <link href="/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序先选取一个 <strong>步长</strong>，按照步长来分组，进行组内排序，然后减少步长，重复以上操作，直到步长为 1。比如说，步长为 3，待排序列的长度为 10，那么对序列中下标为 0 3 6 9 的的元素进行排序。</p><p>希尔排序是 <strong>不稳定</strong> 的排序算法。</p><blockquote><p>希尔排序的间隔序列不推荐用2的幂(1 2 4 8 16…)，因为这样直到间隔为1之前，都不会将奇数位置与偶数位置的元素进行比较，这样是低效的。希尔自己认为可以用2的幂 - 1序列(1 3 7 15…)，后来又有文章建议用3x + 1(1 4 13 40 121…)，都是可以的。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//简易版希尔排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">//外层步长控制,每次都 /2</span><br><span class="hljs-keyword">for</span> step := <span class="hljs-built_in">len</span>(nums) / <span class="hljs-number">2</span>; step &gt; <span class="hljs-number">0</span>; step /= <span class="hljs-number">2</span> &#123;<br><span class="hljs-comment">// i 从step开始，每次迭代都 +step，直到超出数组长度</span><br><span class="hljs-keyword">for</span> i := step; i &lt; <span class="hljs-built_in">len</span>(nums); i += step &#123;<br><span class="hljs-comment">//排序位于步长上的数</span><br><span class="hljs-comment">//比较 i（对应第x次步长上的数）与 i-step 上的数，把大的数后移，小的数前移，每次迭代后，i-step。</span><br><span class="hljs-comment">//从后往前扫描，i 每次迭代都让 j 离末尾更近</span><br><span class="hljs-keyword">for</span> j := i - step; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j+step] &lt; nums[j]; j -= step &#123;<br>nums[j], nums[j+step] = nums[j+step], nums[j]<br>&#125;<br>fmt.Println(nums, <span class="hljs-string">&quot;step: &quot;</span>, step, <span class="hljs-string">&quot;i: &quot;</span>, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 实现二分排序</title>
    <link href="/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/22/golang-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>二分排序，又叫二分插入排序或二分查找法。基本思想是在插入第 i 个元素时，折半比较中间的元素，若要插入的元素比它小，则再折半比较，若比它大，则对后部分进行折半，直到找到合适的位置。适用于有序序列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>arr = <span class="hljs-built_in">append</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>)<br>target := <span class="hljs-number">3</span><br>index := BinarySearch(arr, target)<br><br><span class="hljs-keyword">if</span> index != <span class="hljs-number">-1</span> &#123;<br><span class="hljs-comment">//插入target，并把下标都后移一位</span><br>arr = <span class="hljs-built_in">append</span>(arr, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>; i &gt; index; i-- &#123;<br>arr[i] = arr[i<span class="hljs-number">-1</span>]<br>&#125;<br>arr[index<span class="hljs-number">-1</span>] = target<br>&#125;<br>fmt.Println(arr)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">//左右边界</span><br>left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><span class="hljs-comment">//找到满足 mid-1 &lt; target &lt; mid 的下标</span><br><span class="hljs-keyword">for</span> left &lt;= right &#123;<br>mid := left + (right-left)/<span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> nums[mid] &gt;= target &amp;&amp; nums[mid<span class="hljs-number">-1</span>] &lt; target &#123;<br><span class="hljs-keyword">return</span> mid<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 实现快速排序</title>
    <link href="/2022/06/21/golang-%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/21/golang-%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>基本思想：选取一个哨兵(这里选了第一个数)，把比它小的放左边，比它大的放右边，再左右分别排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    mid, i := values[<span class="hljs-number">0</span>], <span class="hljs-number">1</span><br>    <span class="hljs-comment">//分别为头下标和尾下标</span><br>    head, tail := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(values)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> head &lt; tail &#123;<br>        <span class="hljs-comment">//选取第一个数（head）作为哨兵，比较相邻的数，比它大的从末尾开始放置；比它小的，head++，且两数交换</span><br>        <span class="hljs-keyword">if</span> values[i] &gt; mid &#123;<br>            values[i], values[tail] = values[tail], values[i]<br>            tail--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            values[i], values[head] = values[head], values[i]<br>            head++<br>            i++<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//给哨兵的左右序列进行排序</span><br>    values[head] = mid<br>    Quick2Sort(values[:head])<br>    Quick2Sort(values[head+<span class="hljs-number">1</span>:])<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 实现冒泡排序</title>
    <link href="/2022/06/21/golang%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/21/golang%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>基本思想：依次比较两个相邻的元素，并排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(arr)-  i; j++ &#123;<br><span class="hljs-keyword">if</span> arr[j] &lt; arr[j<span class="hljs-number">-1</span>] &#123;<br>arr[j],arr[j<span class="hljs-number">-1</span>]=arr[j<span class="hljs-number">-1</span>],arr[j]<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang 实现简单选择排序算法</title>
    <link href="/2022/06/21/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/06/21/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>简单选择排序是一种不稳定排序算法。它会每次从左至右扫描序列，记下最小值的位置，按顺序依次放置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleSelectSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">//终止递归</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>temp := arr[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(arr)]<br>minIndex := <span class="hljs-number">0</span><br>minValue := temp[<span class="hljs-number">0</span>]<br><span class="hljs-comment">//寻找最小的数</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(temp); i++ &#123;<br><span class="hljs-keyword">if</span> arr[i] &lt; minValue &#123;<br>minIndex = i<br>minValue = temp[i]<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//把最小的数放置到首位</span><br><span class="hljs-keyword">if</span> temp[<span class="hljs-number">0</span>] != temp[minIndex] &#123;<br>temp[<span class="hljs-number">0</span>] = temp[<span class="hljs-number">0</span>] + temp[minIndex]<br>temp[minIndex] = temp[<span class="hljs-number">0</span>] - temp[minIndex]<br>temp[<span class="hljs-number">0</span>] = temp[<span class="hljs-number">0</span>] - temp[minIndex]<br>&#125;<br>    <span class="hljs-comment">//递归并把元素从小到大排序</span><br>temp = temp[<span class="hljs-number">1</span>:]<br>SimpleSelectSort(temp)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>更新</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//不需要创建temp，因为 Go 在传入引用类型时传的是副本</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SimpleSelectSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>minIndex := <span class="hljs-number">0</span><br>minValue := arr[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-keyword">if</span> arr[i] &lt; minValue &#123;<br>minIndex = i<br>minValue = arr[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> arr[<span class="hljs-number">0</span>] != arr[minIndex] &#123;<br>arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>] + arr[minIndex]<br>arr[minIndex] = arr[<span class="hljs-number">0</span>] - arr[minIndex]<br>arr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>] - arr[minIndex]<br>&#125;<br>arr = arr[<span class="hljs-number">1</span>:]<br>SimpleSelectSort(arr)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的Socket编程_入门</title>
    <link href="/2022/06/21/Go%E4%B8%AD%E7%9A%84Socket%E7%BC%96%E7%A8%8B-%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/21/Go%E4%B8%AD%E7%9A%84Socket%E7%BC%96%E7%A8%8B-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Socket？"><a href="#什么是-Socket？" class="headerlink" title="什么是 Socket？"></a>什么是 Socket？</h1><p>Socket 起源于 Unix，而 Unix 基本哲学之一就是“一切皆文件”，都可以用“打开 open –&gt; 读写 write&#x2F;read –&gt; 关闭 close”模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I&#x2F;O，Socket 也是一种文件描述符。Socket 也具有一个类似于打开文件的函数调用：Socket()，该函数返回一个整型的 Socket 描述符随后的连接建立、数据传输等操作都是通过该 Socket 实现的。</p><p>常用的 <strong>Socket 类型</strong> 有两种：<strong>流式</strong> Socket（SOCK_STREAM）和<strong>数据报式</strong> Socket（SOCK_DGRAM）。流式是一种**面向连接 **的 Socket，针对于面向连接的 <strong>TCP</strong> 服务 应用；数据报式 Socket 是一种 <strong>无连接</strong> 的 Socket，对应于无连接的 <strong>UDP</strong> 服务应用。</p><h1 id="Socket-如何通信"><a href="#Socket-如何通信" class="headerlink" title="Socket 如何通信"></a>Socket 如何通信</h1><p>网络中的进程之间要进行通信，首要的问题是 <strong>如何唯一标识一个进程</strong>。在本地可以通过进程 PID 来唯一标识一个进程，但是在网络中这是行不通的。</p><p><strong>TCP&#x2F;IP</strong> 协议族已经帮我们解决了这个问题，网络层的“ip 地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（<strong>ip 地址，协议，端口</strong>）就可以标识网络的进程了，网络中需要互相通信的进程， 就可以利用这个标志在他们之间进行交互。</p><h1 id="TCP-Socket"><a href="#TCP-Socket" class="headerlink" title="TCP Socket"></a>TCP Socket</h1><p>通过网络端口访问一个服务时，我们能够做什么呢？</p><ul><li><p>对于服务端，我们需要把服务 <strong>绑定</strong> 到某个 <strong>指定端口</strong>，并且在此端口上 <strong>监听</strong>，当有客户端来访问时能够读取信息并且写入<strong>反馈</strong>信息。</p></li><li><p>对于客户端来说，可以通过向远端某台机器的的某个网络端口发送一个 <strong>请求</strong>，然后 <strong>得到</strong> 在机器的此端口上监听的服务 <strong>反馈</strong> 的信息。</p></li></ul><p>在 Go 语言的 net 包中有一个类型 <strong>TCPConn</strong>，这个类型可以用来作为客户端和服务器端 <strong>交互的通道</strong>，他有两个主要的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *TCPConn)</span></span> Write(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err os.Error)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *TCPConn)</span></span> Read(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err os.Error)<br><span class="hljs-comment">//TCPConn 可以用在客户端和服务器端来读写数据。</span><br><br><span class="hljs-comment">//此外，还有一个 TCPAddr 类型，他表示一个 TCP 的地址信息</span><br><span class="hljs-keyword">type</span> TCPAddr <span class="hljs-keyword">struct</span> &#123;<br> IP IP<br> Port <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">//通过 ResolveTCPAddr 获取一个 TCPAddr</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResolveTCPAddr</span><span class="hljs-params">(net, addr <span class="hljs-type">string</span>)</span></span> (*TCPAddr, os.Error)<br><span class="hljs-comment">//addr 表示域名或者 IP 地址</span><br><span class="hljs-comment">//net 参数是&quot;tcp4&quot;、&quot;tcp6&quot;、&quot;tcp&quot;中的任意一个，分别表示 TCP(IPv4-only),TCP(IPv6-only)或者 TCP(IPv4,IPv6 的任意一个)</span><br></code></pre></td></tr></table></figure><h2 id="TCP-client"><a href="#TCP-client" class="headerlink" title="TCP client"></a>TCP client</h2><p>Go 语言中通过 net 包中的 <strong>DialTCP</strong> 函数来建立一个 TCP 连接，并返回一个 TCPConn 类型的对象，当连接建立时服务器端也创建一个同类型的对象，此时客户端和服务器段通过各自拥有的 TCPConn 对象来进行 <strong>数据交换</strong>。</p><p>一般而言，客户端通过 TCPConn 对象将请求信息发送到服务器端，读取服务器端响应的信息。服务器端读取并解析来自客户端的请求，并返回应答信息，这个连接只有当任一端关闭了连接之后才失效，不然这连接可以一直在使用。建立连接的函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialTCP</span><span class="hljs-params">(net <span class="hljs-type">string</span>, laddr, raddr *TCPAddr)</span></span> (c *TCPConn, err os.Error)<br><span class="hljs-comment">//laddr 表示本机地址，一般设置为 nil, raddr 表示远程的服务地址</span><br></code></pre></td></tr></table></figure><p>简易客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//命令行参数的第一个为二进制文件生成的地址，第二个为输入</span><br><span class="hljs-comment">//这里是没有输入时的处理</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) != <span class="hljs-number">2</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Usage: %s host:port &quot;</span>, os.Args[<span class="hljs-number">0</span>])<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">//将参数转换成 tcpAddr</span><br>service := os.Args[<span class="hljs-number">1</span>]<br>tcpAddr, err := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp4&quot;</span>, service)<br>checkError(err)<br><span class="hljs-comment">//创建 TCP 连接</span><br>conn, err := net.DialTCP(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-literal">nil</span>, tcpAddr)<br>checkError(err)<br>_, err = conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;HEAD / HTTP/1.0\r\n\r\n&quot;</span>))<br>checkError(err)<br><span class="hljs-comment">//从 conn 中读取文本(服务端的反馈)</span><br>result, err := ioutil.ReadAll(conn)<br>checkError(err)<br>fmt.Println(<span class="hljs-type">string</span>(result))<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Fatal error: %s&quot;</span>, err.Error())<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TCP-server"><a href="#TCP-server" class="headerlink" title="TCP server"></a>TCP server</h2><p>通过 net 包来创建一个服务器端程序后，在服务器端我们需要绑定服务到指定的非激活端口，并监听此端口，当有客户端请求到达的时候可以接收到来自客户端连接的请求。net 包中有相应功能的函数，函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenTCP</span><span class="hljs-params">(net <span class="hljs-type">string</span>, laddr *TCPAddr)</span></span> (l *TCPListener, err os.Error)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *TCPListener)</span></span> Accept() (c Conn, err os.Error)<br></code></pre></td></tr></table></figure><p>实现一个简单的时间同步服务，监听 7777 端口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//监听 7777 端口</span><br>service := <span class="hljs-string">&quot;:7777&quot;</span><br>tcpAddr, err := net.ResolveTCPAddr(<span class="hljs-string">&quot;tcp4&quot;</span>, service)<br>checkError(err)<br>listener, err := net.ListenTCP(<span class="hljs-string">&quot;tcp&quot;</span>, tcpAddr)<br>checkError(err)<br><span class="hljs-comment">//等待客户端请求</span><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">//可以同时接收多个请求，支持高并发</span><br><span class="hljs-keyword">go</span> handlerClient(conn)<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handlerClient</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-comment">//返回当前的时间信息</span><br><span class="hljs-keyword">defer</span> conn.Close()<br>daytime := time.Now().String()<br>conn.Write([]<span class="hljs-type">byte</span>(daytime))<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="控制-TCP-连接"><a href="#控制-TCP-连接" class="headerlink" title="控制 TCP 连接"></a>控制 TCP 连接</h2><p>TCP 有很多连接控制函数，我们平常用到比较多的有如下几个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *TCPConn)</span></span> SetTimeout(nsec <span class="hljs-type">int64</span>) os.Error<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *TCPConn)</span></span> SetKeepAlive(keepalive <span class="hljs-type">bool</span>) os.Error<br></code></pre></td></tr></table></figure><p>第一个函数用来设置连接的超时时间，客户端和服务器端都适用，当超过设置的时间时该连接就会失效。<br>第二个函数用来设置客户端是否和服务器端一直保持着连接，即使没有任何的数据发送。</p><h1 id="UDP-Socket"><a href="#UDP-Socket" class="headerlink" title="UDP Socket"></a>UDP Socket</h1><p>Go 语言包中处理 UDP Socket 和 TCP Socket 不同的地方就是在服务器端处理多个客户端请求数据包的方式不同,UDP 缺少了对客户端连接请求的 Accept 函数。其他基本几乎一模一样，只有 TCP 换成了 UDP 而已。UDP 的几个主要函数如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResolveUDPAddr</span><span class="hljs-params">(net, addr <span class="hljs-type">string</span>)</span></span> (*UDPAddr, os.Error)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialUDP</span><span class="hljs-params">(net <span class="hljs-type">string</span>, laddr, raddr *UDPAddr)</span></span> (c *UDPConn, err os.Error)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenUDP</span><span class="hljs-params">(net <span class="hljs-type">string</span>, laddr *UDPAddr)</span></span> (c *UDPConn, err os.Error)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *UDPConn)</span></span> ReadFromUDP(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, addr *UDPAddr, err os.Error<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *UDPConn)</span></span> WriteToUDP(b []<span class="hljs-type">byte</span>, addr *UDPAddr) (n <span class="hljs-type">int</span>, err os.Error)<br></code></pre></td></tr></table></figure><p>一个 UDP 的客户端代码如下所示,我们可以看到不同的就是 TCP 换成了 UDP 而已：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) != <span class="hljs-number">2</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Usage: %s host:port&quot;</span>, os.Args[<span class="hljs-number">0</span>])<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>service := os.Args[<span class="hljs-number">1</span>]<br>udpAddr, err := net.ResolveUDPAddr(<span class="hljs-string">&quot;udp4&quot;</span>, service)<br>checkError(err)<br>conn, err := net.DialUDP(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-literal">nil</span>, udpAddr)<br>checkError(err)<br>_, err = conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;anything&quot;</span>))<br>checkError(err)<br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">512</span>]<span class="hljs-type">byte</span><br>n, err := conn.Read(buf[<span class="hljs-number">0</span>:])<br>checkError(err)<br>fmt.Println(<span class="hljs-type">string</span>(buf[<span class="hljs-number">0</span>:n]))<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Fatal error &quot;</span>, err.Error())<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>再看一下 UDP 服务器端如何来处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>service := <span class="hljs-string">&quot;:1200&quot;</span><br>udpAddr, err := net.ResolveUDPAddr(<span class="hljs-string">&quot;udp4&quot;</span>, service)<br>checkError(err)<br>conn, err := net.ListenUDP(<span class="hljs-string">&quot;udp&quot;</span>, udpAddr)<br>checkError(err)<br><span class="hljs-keyword">for</span> &#123;<br>handleClient(conn)<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleClient</span><span class="hljs-params">(conn *net.UDPConn)</span></span> &#123;<br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">512</span>]<span class="hljs-type">byte</span><br>_, addr, err := conn.ReadFromUDP(buf[<span class="hljs-number">0</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>daytime := time.Now().String()<br>conn.WriteToUDP([]<span class="hljs-type">byte</span>(daytime), addr)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 文件上传的简单 Demo</title>
    <link href="/2022/06/20/Go-Web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E7%AE%80%E5%8D%95-Demo/"/>
    <url>/2022/06/20/Go-Web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E7%AE%80%E5%8D%95-Demo/</url>
    
    <content type="html"><![CDATA[<h1 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h1><p>使表单能够上传文件，首先第一步就是要添加 form 的 enctype 属性，enctype 属性有如 下三种情况:</p><ul><li><strong>application&#x2F;x-www-form-urlencoded</strong> 表示在发送前编码所有字符（默认）</li><li><strong>multipart&#x2F;form-data</strong> 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</li><li><strong>text&#x2F;plain</strong> 空格转换为 “+” 加号，但不对特殊字符编码。</li></ul><p>所以，表单的 html 代码应该类似于:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://127.0.0.1:9090/upload&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;uploadfile&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;token&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;upload&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>服务器端，我们增加一个 handlerFunc:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go">http.HandleFunc(<span class="hljs-string">&quot;/upload&quot;</span>, upload)<br><span class="hljs-comment">// 处理/upload 逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">upload</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;method:&quot;</span>, r.Method) <span class="hljs-comment">//获取请求的方法</span><br><span class="hljs-keyword">if</span> r.Method == <span class="hljs-string">&quot;GET&quot;</span> &#123;<br>crutime := time.Now().Unix()<br>h := md5.New()<br>io.WriteString(h, strconv.FormatInt(crutime, <span class="hljs-number">10</span>))<br>token := fmt.Sprintf(<span class="hljs-string">&quot;%x&quot;</span>, h.Sum(<span class="hljs-literal">nil</span>))<br>t, _ := template.ParseFiles(<span class="hljs-string">&quot;upload.gtpl&quot;</span>)<br>t.Execute(w, token)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">//参数为maxMemory，这里是32m，大于32m的部分将存储在系统的临时文件中。</span><br>r.ParseMultipartForm(<span class="hljs-number">32</span> &lt;&lt; <span class="hljs-number">20</span>)<br>file, handler, err := r.FormFile(<span class="hljs-string">&quot;uploadfile&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%v&quot;</span>, handler.Header)<br>f, err := os.OpenFile(<span class="hljs-string">&quot;./test/&quot;</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br>        <span class="hljs-comment">//存储文件</span><br>io.Copy(f, file)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p>上传文件主要有三步处理：</p><ol><li>表单中增加 enctype&#x3D;”multipart&#x2F;form-data”</li><li>服务端调用 r.ParseMultipartForm, 把上传的文件存储在 <strong>内存和临时文件</strong> 中</li><li>使用 r.FormFile 获取文件句柄，然后对文件进行存储等处理。</li></ol><h1 id="客户端上传文件"><a href="#客户端上传文件" class="headerlink" title="客户端上传文件"></a>客户端上传文件</h1><p>Go 支持 模拟客户端表单功能支持文件上传，客户端通过 multipart.Write 把文件的文本流写入一个缓存中，然后调用 http 的 Post 方法把缓存传到服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;mime/multipart&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>, targetUrl <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>bodyBuf := &amp;bytes.Buffer&#123;&#125;<br>bodyWriter := multipart.NewWriter(bodyBuf)<br><span class="hljs-comment">//关键的一步操作</span><br>fileWriter, err := bodyWriter.CreateFormFile(<span class="hljs-string">&quot;uploadfile&quot;</span>, filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;error writing to buffer&quot;</span>)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">//打开文件句柄操作</span><br>fh, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;error opening file&quot;</span>)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">//iocopy</span><br>_, err = io.Copy(fileWriter, fh)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>contentType := bodyWriter.FormDataContentType()<br>bodyWriter.Close()<br>resp, err := http.Post(targetUrl, contentType, bodyBuf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br>resp_body, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>fmt.Println(resp.Status)<br>fmt.Println(<span class="hljs-type">string</span>(resp_body))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// sample usage</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>target_url := <span class="hljs-string">&quot;http://localhost:9090/upload&quot;</span><br>filename := <span class="hljs-string">&quot;./astaxie.pdf&quot;</span><br>postFile(filename, target_url)<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web 服务器端验证表单输入</title>
    <link href="/2022/06/20/Go-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5/"/>
    <url>/2022/06/20/Go-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="设置必填字段"><a href="#设置必填字段" class="headerlink" title="设置必填字段"></a>设置必填字段</h1><p>Go 有一个内置函数 len 可以获取字符串的长度，可以通过 len 来获取数据的长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.Form[<span class="hljs-string">&quot;username&quot;</span>][<span class="hljs-number">0</span>])==<span class="hljs-number">0</span>&#123;<br> <span class="hljs-comment">//为空的处理，这样可以限制一些字段为必填字段</span><br> <span class="hljs-comment">//可以判断空文本框、空文本区域以及文件上传</span><br> <span class="hljs-comment">//但不能判断未选中的复选框和单选按钮</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以用 <strong>r.Form.Get()</strong> 来获取值，因为如果字段不存在，通过该方式获取的是空值。但是通过 r.Form.Get() 只能获取单个的值，如果是 map 的值，必须通过上面的方式来获取。</p><h1 id="限制输入为数字"><a href="#限制输入为数字" class="headerlink" title="限制输入为数字"></a>限制输入为数字</h1><p>判断正整数时，那可以先转化成 int 类型，然后进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">getint,err:=strconv.Atoi(r.Form.Get(<span class="hljs-string">&quot;age&quot;</span>))<br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br> <span class="hljs-comment">//数字转化出错了，那么可能就是不是数字</span><br>&#125;<br><span class="hljs-comment">//接下来就可以判断这个数字的大小范围了</span><br><span class="hljs-keyword">if</span> getint &gt;<span class="hljs-number">100</span> &#123;<br> <span class="hljs-comment">//太大了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以用正则匹配：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> m, _ := regexp.MatchString(<span class="hljs-string">&quot;^[0-9]+$&quot;</span>, r.Form.Get(<span class="hljs-string">&quot;age&quot;</span>)); !m &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="限制为中文"><a href="#限制为中文" class="headerlink" title="限制为中文"></a>限制为中文</h1><p>目前有效的验证方式只有正则表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> m, _ := regexp.MatchString(<span class="hljs-string">&quot;^[\\x&#123;4e00&#125;-\\x&#123;9fa5&#125;]+$&quot;</span>, r.Form.Get(<span class="hljs-string">&quot;realname&quot;</span>)); !m &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="限制为英文"><a href="#限制为英文" class="headerlink" title="限制为英文"></a>限制为英文</h1><p>正则表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> m, _ := regexp.MatchString(<span class="hljs-string">&quot;^[a-zA-Z]+$&quot;</span>, r.Form.Get(<span class="hljs-string">&quot;engname&quot;</span>)); !m &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="电子邮件地址"><a href="#电子邮件地址" class="headerlink" title="电子邮件地址"></a>电子邮件地址</h1><p>验证 Email 地址是否正确，通过如下这个方式可以验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> m, _ := regexp.MatchString(<span class="hljs-string">`^([\w\.\_]&#123;2,10&#125;)@(\w&#123;1,&#125;).([a-z]&#123;2,4&#125;)$`</span>, <br>r.Form.Get(<span class="hljs-string">&quot;email&quot;</span>)); !m &#123;<br> fmt.Println(<span class="hljs-string">&quot;no&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br> fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h1><p>你想要判断用户输入的手机号码是否正确，通过正则也可以验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> m, _ := regexp.MatchString(<span class="hljs-string">`^(1[3|4|5|8][0-9]\d&#123;4,8&#125;)$`</span>, r.Form.Get(<span class="hljs-string">&quot;mobile&quot;</span>)); !<br>m &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h1><p>判断表单里面<select>元素生成的下拉菜单中是否有被选中的项目。有些时候黑客可能会伪造这个下拉菜单不存在的值发送给你，那么如何判断这个值是否是我们预设的值呢？<br>我们的 select 可能是这样的一些元素</p><select name="fruit"><option value="apple">apple</option><option value="pear">pear</option><option value="banane">banane</option></select>那么我们可以这样来验证<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">slice:=[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;pear&quot;</span>,<span class="hljs-string">&quot;banane&quot;</span>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> slice &#123;<br> <span class="hljs-keyword">if</span> v == r.Form.Get(<span class="hljs-string">&quot;fruit&quot;</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br> &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h1><p>如果我们想要判断 radio 按钮是否有一个被选中了，与·下拉菜单的判断方式类似，判断我们获取<br>的值是我们预设的值，而不是额外的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>女<br></code></pre></td></tr></table></figure><p>那我们可以类似下拉菜单的做法一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">slice:=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> slice &#123;<br> <span class="hljs-keyword">if</span> v == r.Form.Get(<span class="hljs-string">&quot;gender&quot;</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br> &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h1><p>有一项选择兴趣的复选框，你想确定用户选中的和你提供给用户选择的是同一个类型的数<br>据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span>&gt;</span>足球<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span>&gt;</span>篮球<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;interest&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tennis&quot;</span>&gt;</span>网球<br></code></pre></td></tr></table></figure><p>对于复选框我们的验证和单选有点不一样，因为接收到的数据是一个 slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">slice:=[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;football&quot;</span>,<span class="hljs-string">&quot;basketball&quot;</span>,<span class="hljs-string">&quot;tennis&quot;</span>&#125;<br>a:=Slice_diff(r.Form[<span class="hljs-string">&quot;interest&quot;</span>],slice)<br><span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 中的 http 包</title>
    <link href="/2022/06/19/Go-%E4%B8%AD%E7%9A%84-http-%E5%8C%85/"/>
    <url>/2022/06/19/Go-%E4%B8%AD%E7%9A%84-http-%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>Go 的 http 有两个核心功能：Conn、ServeMux。</p><h1 id="Conn"><a href="#Conn" class="headerlink" title="Conn"></a>Conn</h1><p>与我们一般编写的 http 服务器不同, Go 为了实现高并发和高性能, 使用了 goroutines 来处 理 Conn 的读写事件, 这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事 件。这是 Go 高效的保证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//net 包下的 Conn 定义</span><br><span class="hljs-keyword">type</span> Conn <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Read reads data from the connection.（从连接中读取数据）</span><br><span class="hljs-comment">// Read can be made to time out and return an error after a fixed（可以设置读取超时，修复后将会报错</span><br><span class="hljs-comment">// time limit; see SetDeadline and SetReadDeadline. （时间限制参考SetDeadline和SetReadDeadline）</span><br>Read(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Write writes data to the connection.（往连接中写入数据）</span><br><span class="hljs-comment">// Write can be made to time out and return an error after a fixed</span><br><span class="hljs-comment">// time limit; see SetDeadline and SetWriteDeadline.</span><br>Write(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br><br>    <span class="hljs-comment">// Close closes the connection. (关闭连接)</span><br><span class="hljs-comment">// Any blocked Read or Write operations will be unblocked and return errors.（调用Close后，任何阻塞的Read或Write操作都将被解锁并返回错误）</span><br>Close() <span class="hljs-type">error</span><br><br><span class="hljs-comment">// LocalAddr returns the local network address, if known.（若已知，返回本地网络地址）</span><br>LocalAddr() Addr<br><br><span class="hljs-comment">// RemoteAddr returns the remote network address, if known.（若已知，RemoteAddr 返回远程网络地址）</span><br>RemoteAddr() Addr<br><br><span class="hljs-comment">// SetDeadline sets the read and write deadlines associated</span><br><span class="hljs-comment">// with the connection. It is equivalent to calling both</span><br><span class="hljs-comment">// SetReadDeadline and SetWriteDeadline.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A deadline is an absolute time after which I/O operations</span><br><span class="hljs-comment">// fail instead of blocking. The deadline applies to all future</span><br><span class="hljs-comment">// and pending I/O, not just the immediately following call to</span><br><span class="hljs-comment">// Read or Write. After a deadline has been exceeded, the</span><br><span class="hljs-comment">// connection can be refreshed by setting a deadline in the future.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If the deadline is exceeded a call to Read or Write or to other</span><br><span class="hljs-comment">// I/O methods will return an error that wraps os.ErrDeadlineExceeded.</span><br><span class="hljs-comment">// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).</span><br><span class="hljs-comment">// The error&#x27;s Timeout method will return true, but note that there</span><br><span class="hljs-comment">// are other possible errors for which the Timeout method will</span><br><span class="hljs-comment">// return true even if the deadline has not been exceeded.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// An idle timeout can be implemented by repeatedly extending</span><br><span class="hljs-comment">// the deadline after successful Read or Write calls.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A zero value for t means I/O operations will not time out.</span><br>SetDeadline(t time.Time) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// SetReadDeadline sets the deadline for future Read calls</span><br><span class="hljs-comment">// and any currently-blocked Read call.</span><br><span class="hljs-comment">// A zero value for t means Read will not time out.</span><br>SetReadDeadline(t time.Time) <span class="hljs-type">error</span><br><br><span class="hljs-comment">// SetWriteDeadline sets the deadline for future Write calls</span><br><span class="hljs-comment">// and any currently-blocked Write call.</span><br><span class="hljs-comment">// Even if write times out, it may return n &gt; 0, indicating that</span><br><span class="hljs-comment">// some of the data was successfully written.</span><br><span class="hljs-comment">// A zero value for t means Write will not time out.</span><br>SetWriteDeadline(t time.Time) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在等待客户端请求时，Go的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">c, err := srv.newConn(rw)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> c.serve()<br><span class="hljs-comment">//客户端的每次请求都会创建一个 Conn，这个 Conn 里面保存了该次请求的信息</span><br><span class="hljs-comment">//然后再传递到对应的 handler，该 handler 中便可以读取到相应的 header 信息</span><br><span class="hljs-comment">//这样保证了每个请求的独立性。</span><br><br></code></pre></td></tr></table></figure><h1 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h1><p>http 包下的 ServeMux：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ServeMux <span class="hljs-keyword">struct</span> &#123;<br>   mu    sync.RWMutex<span class="hljs-comment">//锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span><br>   m     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]muxEntry<span class="hljs-comment">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 是注册的路由表达式</span><br>   es    []muxEntry    <span class="hljs-comment">// 从最长到最短排序的条目切片</span><br>   hosts <span class="hljs-type">bool</span>          <span class="hljs-comment">// 是否有任何模式包含主机名</span><br>&#125;<br><br><span class="hljs-keyword">type</span> muxEntry <span class="hljs-keyword">struct</span> &#123;<br>h       Handler<span class="hljs-comment">//表示路由表达式对应的 handler </span><br>pattern <span class="hljs-type">string</span><span class="hljs-comment">//路由表达式</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br> ServeHTTP(ResponseWriter, *Request) <span class="hljs-comment">// 路由实现器</span><br>&#125;<br></code></pre></td></tr></table></figure><p>路由器里面存储好了相应的路由规则，再接收到请求之后调用 mux.handler(r).ServeHTTP(w, r)，即对应路由的handler 的 ServerHTTP 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span></span> handler(r *Request) Handler &#123;<br> mux.mu.RLock()<br> <span class="hljs-keyword">defer</span> mux.mu.RUnlock()<br> <span class="hljs-comment">// Host-specific pattern takes precedence over generic ones</span><br> h := mux.match(r.Host + r.URL.Path)<br> <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br> h = mux.match(r.URL.Path)<br> &#125;<br> <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br> h = NotFoundHandler()<br> &#125;<br> <span class="hljs-keyword">return</span> h<br>&#125;<br><span class="hljs-comment">//他根据用户请求的 URL 和路由器里面存储的 map 去匹配的，当匹配到之后返回存储的 handler，调用这个 handler 的 ServHTTP 接口就可以执行到相应的函数了。</span><br></code></pre></td></tr></table></figure><p><strong>可以在自己实现的路由器的 ServHTTP 里面实现自定义路由功能，ListenAndServe 的第二个参数就是用以配置外部路由器的，它是一个 Handler 接口，即外部路由器只要实现了 Handler 接口就可以。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyMux <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *MyMux)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br><span class="hljs-keyword">if</span> r.URL.Path == <span class="hljs-string">&quot;/&quot;</span> &#123;<br>sayhelloName(w, r)<br><span class="hljs-keyword">return</span><br>&#125;<br>http.NotFound(w, r)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayhelloName</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Hello myroute!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mux := &amp;MyMux&#123;&#125;<br>http.ListenAndServe(<span class="hljs-string">&quot;:9090&quot;</span>, mux)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 搭建一个 web 服务器</title>
    <link href="/2022/06/19/Go-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA-web-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/06/19/Go-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA-web-%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>Go 语言里面提供了一个完善的 net&#x2F;http 包，通过 http 包可以很方便的就搭建起来一个可以运行的 web 服务。同时使用这个 包能很简单地对 web 的路由，静态文件，模版，cookie 等数据进行设置和操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayhelloName</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>r.ParseForm() <span class="hljs-comment">//解析函数</span><br>fmt.Println(r.Form)<br>fmt.Println(<span class="hljs-string">&quot;path&quot;</span>, r.URL.Path)<br>fmt.Println(<span class="hljs-string">&quot;scheme&quot;</span>, r.URL.Scheme)<br><span class="hljs-built_in">println</span>(r.Form[<span class="hljs-string">&quot;url_long&quot;</span>])<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;<br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, k)<br>fmt.Println(<span class="hljs-string">&quot;val:&quot;</span>, strings.Join(v, <span class="hljs-string">&quot;&quot;</span>))<br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Hello!&quot;</span>) <span class="hljs-comment">//网页中输出</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, sayhelloName) <span class="hljs-comment">//设置访问路由</span><br>err := http.ListenAndServe(<span class="hljs-string">&quot;:9090&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;ListenAndServe: &quot;</span>, err)<br>&#125;<br>&#125;<br><span class="hljs-comment">//在浏览器输入 http://localhost:9090 可以看到浏览器页面输出了 Hello!</span><br></code></pre></td></tr></table></figure><h1 id="Go-实现-Web-服务的流程图"><a href="#Go-实现-Web-服务的流程图" class="headerlink" title="Go 实现 Web 服务的流程图"></a>Go 实现 Web 服务的流程图</h1><p><img src="https://upload-images.jianshu.io/upload_images/1640397-0a48ca6896e1812a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/502/format/webp" alt="img"></p><ol><li>创建 Listen Socket，监听指定的端口，等待客户端请求到来</li><li>Listen Socket 接受客户端的请求, 得到 Client Socket, 接下来通过 Client Socket 与 客户端通信</li><li>处理客户端的请求。首先从 Client Socket 读取 HTTP 请求的协议头, 如果是 POST 方法, 还可能要读取客户端提交的数据, 然后交给相应的 handler 处理请求, handler 处理完毕准备好客户端需要的数据, 通过 Client Socket 写给客户端</li></ol><h2 id="Go-如何让web运行起来"><a href="#Go-如何让web运行起来" class="headerlink" title="Go 如何让web运行起来"></a>Go 如何让web运行起来</h2><p>Go 是通过一个函数 <strong>ListenAndServe</strong> 来处理这些事情的，这个底层其实这样处理的：初始化一个 server 对象，然后调用了 net.Listen(“tcp”,  addr)，也就是底层用 TCP 协议搭建了一个服务，然后监控我们设置的端口。</p><p><strong>Go 的 http 包的源码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">defer</span> l.Close()<br><span class="hljs-keyword">var</span> tempDelay time.Duration <span class="hljs-comment">// how long to sleep on accept failure</span><br>    <span class="hljs-comment">//创建 Conn，把请求的数据作为参数，开启服务(go c.serve)。用户的每一次请求都会创建一个新的 goroutine 去服务</span><br><span class="hljs-keyword">for</span> &#123;<br>rw, e := l.Accept()<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;<br><span class="hljs-keyword">if</span> tempDelay == <span class="hljs-number">0</span> &#123;<br>tempDelay = <span class="hljs-number">5</span> * time.Millisecond<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tempDelay *= <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">if</span> max := <span class="hljs-number">1</span> * time.Second; tempDelay &gt; max &#123;<br>tempDelay = max<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;http: Accept error: %v; retrying in %v&quot;</span>, e, tempDelay)<br>time.Sleep(tempDelay)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> e<br>&#125;<br>        <br>tempDelay = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> srv.ReadTimeout != <span class="hljs-number">0</span> &#123;<br>rw.SetReadDeadline(time.Now().Add(srv.ReadTimeout))<br>&#125;<br><span class="hljs-keyword">if</span> srv.WriteTimeout != <span class="hljs-number">0</span> &#123;<br>rw.SetWriteDeadline(time.Now().Add(srv.WriteTimeout))<br>&#125;<br>c, err := srv.newConn(rw)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> c.serve()<br>&#125;<br>    <br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;not reached&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>conn 首先会解析 request: c.readRequest(), 然后获取相应的 handler: handler :&#x3D; c.server.Handler，也就是我们刚才在调用函数 ListenAndServe 时候的第二个参数，我们前面例子传递的是 nil，也就是为空。这样将会默认取 handler &#x3D; <strong>DefaultServeMux</strong>。</p><p>这个变量是一个 <strong>路由器</strong>，它用来匹配 url 跳转到其相应的 handle 函数，即 http.HandleFunc(“&#x2F;“, sayhelloName)。它是注册了请求 “&#x2F;” 的路由规则，当请求 uri 为”&#x2F;“，路由就会转到函数 <strong>sayhelloName</strong>，DefaultServeMux 会调用 ServeHTTP 方法，这个方法内部其实就是调用 sayhelloName 本身，最后通过写入 response 的信息反馈到客户端。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 协议概述</title>
    <link href="/2022/06/19/HTTP-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/06/19/HTTP-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>HTTP</strong> 是一种让 Web 服务器与浏览器(客户端)通过 <strong>Internet 发送与接收数据</strong>的协议, 它 <strong>建立在 TCP 协议之上</strong>，一般采用 TCP 的 <strong>80 端口</strong>。它是一个请求、响应协议 —— 客户端发出一个请求，服务器响应这个请求。在HTTP中，客户端总是通过建立一个连接与发送一个 HTTP 请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的HTTP连接。</p><p>HTTP 协议是 <strong>无状态的</strong>，同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web 程序引入了 <strong>Cookie</strong> 机制来维护连接的可持续状态。</p><h1 id="HTTP-请求-Request-包（浏览器信息）"><a href="#HTTP-请求-Request-包（浏览器信息）" class="headerlink" title="HTTP 请求(Request)包（浏览器信息）"></a>HTTP 请求(Request)包（浏览器信息）</h1><p>Request 包分为 3 个部分，第一部分叫 <strong>Request line（请求行）</strong>，第二部分叫 <strong>Request header（请求头）</strong>，第三部分叫 <strong>body（主体）</strong>。header 和 body 之间有个空行。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">GET /domains/example/ HTTP/1.1 //请求行: 请求方法 请求URI HTTP协议/协议版本<br>Host：www.iana.org //服务端的主机名<br>User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4 //浏览器信息<br>Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 //客户端能接收的mine<br>Accept-Encoding：gzip,deflate,sdch //是否支持流压缩<br>Accept-Charset：UTF-8,*;q=0.5 //客户端字符编码集<br>//空行,用于分割请求头和消息体<br><br>//消息体,请求资源参数,例如POST传递的参数<br></code></pre></td></tr></table></figure><p>Request 会解析用户的请求消息，包括 post、get、cookie、url 等信息</p><h1 id="HTTP响应-Response-包（服务器信息）"><a href="#HTTP响应-Response-包（服务器信息）" class="headerlink" title="HTTP响应(Response)包（服务器信息）"></a>HTTP响应(Response)包（服务器信息）</h1><p>response 包的结构如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK //状态行<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>nginx/1.0.8 //服务器使用的WEB软件名及版本<br>Date:Date: Tue, 30 Oct 2012 04:14:25 GMT //发送时间<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html //服务器发送信息的类型<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked  //表示发送HTTP包是分段发的<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive //保持连接状态<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>90 //主体内容长度<br>//空行 用来分割消息头和主体<br>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... //消息体<br></code></pre></td></tr></table></figure><p>Response 包中的第一行叫做 <strong>状态行</strong>，由HTTP协议 <strong>版本号，状态码，状态消息</strong> 三部分组成。</p><p><strong>状态码</strong> 用来告诉 HTTP 客户端,HTTP服务器是否产生了预期的 Response。HTTP&#x2F;1.1协议中定义了 5 类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别：</p><ul><li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li><li>2XX 成功 - 表示请求已被成功接收，理解，接受</li><li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li><li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li><li>5XX 服务器端错误 - 服务器未能实现合法的请求</li></ul><p>Response 会反馈给客户端信息。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 中的Atomic_简单Demo</title>
    <link href="/2022/06/15/Go-%E4%B8%AD%E7%9A%84Atomic-%E7%AE%80%E5%8D%95Demo/"/>
    <url>/2022/06/15/Go-%E4%B8%AD%E7%9A%84Atomic-%E7%AE%80%E5%8D%95Demo/</url>
    
    <content type="html"><![CDATA[<p>Atomic 提供了用于实现同步算法的低级原子内存原语。例如使用多个 goroutines 访问原子计数器 sync&#x2F;atomic 包。使用 atomic 的接口函数 <strong>保护</strong> 多个 goroutines 都会操作的 <strong>计数器变量</strong>。Atomic 相比 Mutex 更轻量、效率更高，但是对需要保护的变量类型有要求，atomic 只支持对数据型的变量进行保护，不支持复杂数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//始终为正的计数器</span><br><span class="hljs-keyword">var</span> ops <span class="hljs-type">uint64</span><br>    <br>    <span class="hljs-comment">//启动 50 个协程，每次递增计数器大约耗时 1 毫秒</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>                <span class="hljs-comment">//以原子方式递增计数器</span><br>atomic.AddUint64(&amp;ops, <span class="hljs-number">1</span>)<br>time.Sleep(time.Millisecond)<br>&#125;<br>&#125;()<br>&#125;<br>time.Sleep(time.Second)<br><span class="hljs-comment">//使用LoadUint64将当前值的副本提取到opsFinal中，这样，其他协程仍在更新时安全地使用计数器</span><br>opsFinal := atomic.LoadUint64(&amp;ops)<br>fmt.Println(<span class="hljs-string">&quot;ops:&quot;</span>, opsFinal)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是云原生架构？云原生的概念是什么？</title>
    <link href="/2022/06/13/%E4%BA%91%E5%8E%9F%E7%94%9F-%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/06/13/%E4%BA%91%E5%8E%9F%E7%94%9F-%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>云原生 (Cloud Natvie)</strong> 是一种将应用程序以微服务的形式构建并使之运行在容器化和动态编排平台之上的方式，这些平台充分利用了云计算模型的优势。<strong>云原生关注的是应用如何构建和部署，而非运行在哪里</strong>。</p><p>这些技术能够赋能组织&#x2F;企业在公有云、私有云和混合云等现代和动态的开发环境里构建和运行可扩展的应用程序。这些应用程序是从头开始构建的，以松散耦合原则进行系统设计，并且专门针对云级别的规模和性能进行了优化，基于托管服务并利用持续交付来实现可靠性和更快的上市速度。总体目标是提高速度、可扩展性，以及最终提高利润率。</p></blockquote><h1 id="云原生带来了什么"><a href="#云原生带来了什么" class="headerlink" title="云原生带来了什么"></a>云原生带来了什么</h1><ul><li><p><strong>速度</strong>。数以月计才能将一个想法落地成一个实际产品的周期变成了现在的几天甚至几小时。从本质上讲，云原生 (Cloud Native) 策略是关于如何解决技术风险的。过去，我们规避风险的标准方法是保持缓慢而谨慎地行动。云原生 (Cloud Native) 的新方法则是依靠采取 <strong>小型、可逆和低风险</strong> 的步骤来实现迅速前进。</p></li><li><p><strong>可扩展性</strong>。随着业务的发展，在更多的地方为更多的用户提供更广泛的设备支持，同时又要维持灵敏响应和管理成本，而不会导致失败，成为了战略需要。</p></li><li><p><strong>利润</strong>。</p></li><li><p>在云基础设施的新世界中，战略目标是只在新客户上线时购买所需的额外资源。支出从前期的 CAPEX（购买新机器以预期成功）变成了 OPEX（按需支付额外的服务器）。</p></li></ul><h1 id="云原生设计原则"><a href="#云原生设计原则" class="headerlink" title="云原生设计原则"></a>云原生设计原则</h1><h2 id="松散耦合的微服务"><a href="#松散耦合的微服务" class="headerlink" title="松散耦合的微服务"></a>松散耦合的微服务</h2><p><strong>微服务</strong> 是一种将 <strong>单体应用程序</strong> 拆解成 <strong>一套小型服务</strong> 的方法，每个服务都在自己的进程中运行，并使用像 HTTP 等轻量级协议进行通信。这些服务是围绕业务功能构建的，可以通过 <strong>完全自动化</strong> 的部署机制独立进行部署。</p><h2 id="使用最佳的语言和框架组合进行开发"><a href="#使用最佳的语言和框架组合进行开发" class="headerlink" title="使用最佳的语言和框架组合进行开发"></a>使用最佳的语言和框架组合进行开发</h2><p>每个云原生应用程序的服务都应该使用最适合该功能的语言和框架来开发。云原生应用程序是 <strong>多语言的</strong>，服务使用各种编程语言、运行时和框架。例如，开发人员可以使用 Node.js 来开发基于 WebSocket 的实时流服务，同时选择 Python 来构建机器学习基础服务，并选择 spring-boot 来提供 REST APIs 接口。这种细粒度的微服务开发方式使得开发者能够选择最合适的语言和框架来开发去开发特定的任务。</p><h2 id="以互动和协作为中心的-APIs"><a href="#以互动和协作为中心的-APIs" class="headerlink" title="以互动和协作为中心的 APIs"></a>以互动和协作为中心的 APIs</h2><p>云原生服务使用轻量级 APIs，这些 APIs 基于表述性状态转移（REST）等协议来暴露其功能。内部服务使用 Thrift、Protobuf、gRPC 等二进制协议进行通信，以获得更好的性能。</p><h2 id="无状态且可大规模扩展"><a href="#无状态且可大规模扩展" class="headerlink" title="无状态且可大规模扩展"></a>无状态且可大规模扩展</h2><p>云原生应用将其 <strong>状态</strong> 存储在数据库或其他外部实体中，因此实例可以随意上下线，任一实例都可以处理请求。实例不依赖于底层基础设施，底层基础设施允许应用程序以 <strong>高度分布式的方式运行</strong>，并且仍然保持其状态独立于底层基础设施的弹性机制。从可伸缩性的角度来看，架构非常简单，只需向集群添加普通的商用服务器节点就可以扩展应用程序。</p><h2 id="复原韧性作为架构核心"><a href="#复原韧性作为架构核心" class="headerlink" title="复原韧性作为架构核心"></a>复原韧性作为架构核心</h2><p>复原韧性是指 <strong>系统从故障中恢复并继续运行</strong> 的能力。它不是故障规避，而是以避免停机和数据丢失为目标去处理故障。复原韧性的目标是在发生故障后将应用程序恢复到能完全正常运行的状态。复原韧性提供以下内容：</p><ul><li><strong>高可用性</strong> - 应用程序保持健康状态继续运行的能力而无需大量宕机。</li><li><strong>灾难恢复</strong> - 应用程序从罕见但重大意外事件中恢复的能力：非临时、大规模的故障，比如波及整个区域的服务中断。</li></ul><p>使应用程序更具韧性的主要方法之一是通过冗余机制。HA 和 DR 高可用方案使用多节点集群、多区域部署、数据复制、无单点故障、持续监控等实现。</p><p>以下是实现复原韧性的一些策略：</p><ul><li><strong>重试临时故障</strong> - 临时故障可能是由于网络连接短暂丢失、数据库连接突然掉线或服务繁忙导致的超时造成的。一般这种临时故障能通过简单重试请求来解决。</li><li><strong>跨实例的负载均衡 - 万物集群化</strong>。无状态应用程序应该能够通过向集群添加更多节点进行扩展。</li><li><strong>优雅降级</strong> - 如果一个服务故障且没有故障转移路径，应用程序应该要能优雅降级，同时持续提供可接受的用户体验。</li><li><strong>限流高吞吐的佃户&#x2F;用户</strong> - 有时候一小撮用户可能会产生过多的负载。这将会对其他用户产生影响，从而降低应用程序的整体可用性。</li><li><strong>使用断路器</strong> - 断路器模式可以防止应用程序反复尝试一个可能失败的操作。断路器封装了对服务的调用并跟踪最近的失败次数。如果失败次数超过阈值，则断路器开始返回错误代码而不再是调用服务。</li><li><strong>应用补偿事务</strong> - 补偿事务是一种撤销另一个已完成事务造成的影响的事务。在分布式系统中，实现事务强一致性可能非常困难。补偿事务是一种通过使用一系列更小的单个事务来实现一致性的方法，这些事务的每个步骤都可以被撤消。</li></ul><p>测试复原韧性 – 通常复原韧性测试不能像测试应用程序功能一样（通过运行单元测试、集成测试等）。相反，你必须测试在间歇性发生故障的情况下端到端的工作负载情况。例如：通过崩溃进程注入故障、过期证书、让相关服务不可用等。像<a href="https://github.com/Netflix/chaosmonkey"> chaos monkey </a>这样的框架可以用于这种混沌测试。</p><h2 id="打包成轻量级容器并编排"><a href="#打包成轻量级容器并编排" class="headerlink" title="打包成轻量级容器并编排"></a>打包成轻量级容器并编排</h2><p><strong>容器</strong> 可以将应用程序隔离至共享操作系统内核的小型轻量级执行环境中。容器大小通常以 MB 为单位，因此所使用的资源远远少于虚拟机，并且几乎是瞬时启动。Docker 现在已成为容器技术的标准，它提供的最大优势是 <strong>便携性</strong>。</p><p>云原生应用程序使用 Kubernetes 进行部署，Kubernetes 是一个开源平台，旨在自动部署、扩展和管理容器化应用程序。Kubernetes 最初由谷歌开发，现在已经成为部署云原生应用程序的操作系统。</p><h2 id="通过-CI-x2F-CD-实施敏捷-DevOps-和自动化"><a href="#通过-CI-x2F-CD-实施敏捷-DevOps-和自动化" class="headerlink" title="通过 CI&#x2F;CD 实施敏捷 DevOps 和自动化"></a>通过 CI&#x2F;CD 实施敏捷 DevOps 和自动化</h2><p>DevOps，是“<strong>开发</strong>”和“<strong>运维</strong>”的融合，描述了实现快速敏捷开发和可扩展、可靠运维所需的组织架构、实践和文化。</p><p>持续集成（CI）和持续交付（CD）是一组操作原则，它们使应用程序开发团队能够更频繁、更可靠地交付代码变更。CI 的技术目标是建立一致和自动化的方法来构建、打包和测试应用程序。有了集成过程中的一致性，团队能够更频繁地提交代码变更，从而实现更好的协作和软件质量。</p><p>持续交付 (CD) 负责交接持续集成 (CI)，完成后续的工作。CD 将交付应用程序到选定的基础设施环境的过程自动化，它挑选出 CI 构建完成的应用包，将其部署到像 Dev、QA、Performance 等各种环境中，分阶段运行各种测试，如集成测试、性能测试等，最后部署到生产环境中。通常 CD 的 pipeline 中几乎不需要人工介入，鉴于持续部署 (Continuous Deployment) 是一个完全自动化的 pipeline，从代码拉取到生产环境部署的整个过程都自动化了。</p><h2 id="弹性-动态扩容-x2F-缩容"><a href="#弹性-动态扩容-x2F-缩容" class="headerlink" title="弹性 - 动态扩容&#x2F;缩容"></a>弹性 - 动态扩容&#x2F;缩容</h2><p>得益于云计算的弹性特性，云原生应用得以在运行高峰期通过增加计算资源来缓解压力。如果你部署在云上的电子商务应用正在经历一个流量高峰，你可以设置额外的计算资源给应用，等到高峰消退之后再下线这些资源。云原生应用可以根据需求调整增删的资源和规模。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云计算</tag>
      
      <tag>云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gin 入门</title>
    <link href="/2022/06/01/gin-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/01/gin-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Gin-是什么？"><a href="#Gin-是什么？" class="headerlink" title="Gin 是什么？"></a>Gin 是什么？</h2><p>Gin 是一个用 Go (Golang) 编写的 HTTP Web 框架。 它具有类似 Martini 的 API，但性能比 Martini 快 40 倍。如果你需要极好的性能，使用 Gin 吧。</p><h2 id="Gin-的特性"><a href="#Gin-的特性" class="headerlink" title="Gin 的特性"></a>Gin 的特性</h2><h3 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h3><p>基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。</p><h3 id="支持中间件"><a href="#支持中间件" class="headerlink" title="支持中间件"></a>支持中间件</h3><p>传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。</p><h3 id="Crash-处理"><a href="#Crash-处理" class="headerlink" title="Crash 处理"></a>Crash 处理</h3><p>Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！</p><h3 id="JSON-验证"><a href="#JSON-验证" class="headerlink" title="JSON 验证"></a>JSON 验证</h3><p>Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。</p><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能。</p><h3 id="错误管理"><a href="#错误管理" class="headerlink" title="错误管理"></a>错误管理</h3><p>Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。</p><h3 id="内置渲染"><a href="#内置渲染" class="headerlink" title="内置渲染"></a>内置渲染</h3><p>Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>新建一个中间件非常简单。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>    <br>r.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello Gin！&quot;</span>,<br>&#125;)<br>&#125;)<br>    <br>r.Run(<span class="hljs-string">&quot;:8888&quot;</span>) <span class="hljs-comment">// 监听并在 :8888 端口上启动服务</span><br>&#125;<br><span class="hljs-comment">// 在浏览器中输入 127.0.0.1:8888/hello 将会显示 &quot;message&quot;: &quot;Hello Gin！&quot;  </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 1.19 新特性-pdqsort 算法</title>
    <link href="/2022/05/25/pdqsort%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/25/pdqsort%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>pdqsort 算法，即 pattern defeating quicksort，是一种不稳定的混合排序算法。</p></blockquote><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li>对于短序列（小于一定长度，一般为 12~32），使用插入排序</li><li>其他情况，使用快速排序</li><li>快速排序表现不佳时，使用堆排序来保证最坏情况下，时间复杂度仍然为 O（n*log n）<ul><li>当最终 pivot 的位置离序列两端很接近时（距离小于 length&#x2F;8），判定其表现不佳。当这种情况达到 limit（bits.Len(length))，切换到堆排序。</li></ul></li></ul><blockquote><p>快速排序关于 pivot 的选择</p><ul><li>选取首个元素作为 pivot，是最简单的方案，但在序列有序的情况下，性能很差。</li><li>遍历数组，找中位数作为 pivot，但是多一次遍历，性能不好</li><li>寻找近似中位数<ul><li>对于短序列（&lt;&#x3D;8），选取固定元素</li><li>对于中序列（&lt;&#x3D;50），采样三个元素（一般是前中后三个），选取中位数</li><li>对于长序列（&gt;50)，采样九个元素</li></ul></li></ul></blockquote><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(arr *[7]<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>      insertVal := arr[i]<br>      insertIndex := i - <span class="hljs-number">1</span> <span class="hljs-comment">// 下标</span><br>      <span class="hljs-comment">// 从大到小</span><br>      <span class="hljs-keyword">for</span> insertIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[insertIndex] &lt; insertVal &#123;<br>         arr[insertIndex+<span class="hljs-number">1</span>] = arr[insertIndex] <span class="hljs-comment">// 数据后移</span><br>         insertIndex-- <span class="hljs-comment">// 插入位置前移</span><br>      &#125;<br>      <span class="hljs-comment">// 插入</span><br>      <span class="hljs-keyword">if</span> insertIndex+<span class="hljs-number">1</span> != i &#123;<br>         arr[insertIndex+<span class="hljs-number">1</span>] = insertVal<br>      &#125;<br>      <span class="hljs-comment">//fmt.Printf(&quot;第%d次插入后 %v\n&quot;,i, *arr)</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>, array *[9]<span class="hljs-type">int</span>)</span></span> &#123;<br>   l := left<br>   r := right<br>   <span class="hljs-comment">// pivot 是中轴， 支点</span><br>   pivot := array[(left+right)/<span class="hljs-number">2</span>]<br>   temp := <span class="hljs-number">0</span><br>   <span class="hljs-comment">// for 循环的目标是将比 pivot 小的数放到左边，比 pivot 大的数放到右边</span><br>   <span class="hljs-keyword">for</span> l &lt; r &#123;<br>      <span class="hljs-comment">// 从 pivot 的左边找到大于等于pivot的值</span><br>      <span class="hljs-keyword">for</span> array[l] &lt; pivot &#123;<br>         l++<br>      &#125;<br>      <span class="hljs-comment">// 从 pivot 的右边边找到小于等于pivot的值</span><br>      <span class="hljs-keyword">for</span> array[r] &gt; pivot &#123;<br>         r--<br>      &#125;<br>      <span class="hljs-comment">// 1 &gt;= r 表明本次分解任务完成, break</span><br>      <span class="hljs-keyword">if</span> l &gt;= r &#123;<br>         <span class="hljs-keyword">break</span><br>      &#125;<br>      <span class="hljs-comment">// 交换</span><br>      temp = array[l]<br>      array[l] = array[r]<br>      array[r] = temp<br>      <span class="hljs-comment">// 优化</span><br>      <span class="hljs-keyword">if</span> array[l] == pivot &#123;<br>         r--<br>      &#125;<br>      <span class="hljs-keyword">if</span> array[r] == pivot &#123;<br>         l++<br>      &#125;<br>   &#125;<br>   <span class="hljs-comment">// 如果  1== r, 再移动下</span><br>   <span class="hljs-keyword">if</span> l == r &#123;<br>      l++<br>      r--<br>   &#125;<br>   <span class="hljs-comment">// 向左递归</span><br>   <span class="hljs-keyword">if</span> left &lt; r &#123;<br>      QuickSort(left, r, array)<br>   &#125;<br>   <span class="hljs-comment">// 向右递归</span><br>   <span class="hljs-keyword">if</span> right &gt; l &#123;<br>      QuickSort(l, right, array)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123; <span class="hljs-comment">//arr.length = n</span><br>    <span class="hljs-comment">//构建大根堆</span><br>    buildMaxHeap(arr)<br>    <span class="hljs-comment">//排序 n-1 次</span><br>    <span class="hljs-keyword">for</span>(i:=arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        swap(arr, <span class="hljs-number">0</span>, i) <span class="hljs-comment">// 将最大值交换到数组最后</span><br>        maxHeapify(arr, <span class="hljs-number">0</span>, i); <span class="hljs-comment">//调整交换后的结点</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//构建大根堆 代码：</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br>    从最后一个非叶子节点开始调整大根堆<br>    最后一个非叶子节点为 arr.length/<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        maxHeapify(arr, i, arr.length);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//调整大顶堆 代码：</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, i, haepSize <span class="hljs-type">int</span>)</span></span>&#123; <span class="hljs-comment">//i：要进行调整为堆的非叶子节点结点，heapSize：堆的大小</span><br>    <span class="hljs-comment">//左子树下标</span><br>    l := <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span><br>    <span class="hljs-comment">//右子树下标</span><br>    r := l + <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 记录根结点、左子树结点、右子树结点三者中的最大值下标</span><br>    largest := i<br>    <span class="hljs-keyword">if</span>(l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest])&#123;<br>        largest = l  <br>    &#125;<br>    <span class="hljs-keyword">if</span>(r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest])&#123;<br>        largest = r   <br>    &#125;<br>    <span class="hljs-keyword">if</span>(i != largest)&#123;<br>        <span class="hljs-comment">//交换位置</span><br>        swag(arr, i, largest)<br>        <span class="hljs-comment">// 再次调整交换数字后的大顶堆</span><br>        maxHeapify(arr, largest, heapSize)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span> &#123;<br>    temp := arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pdqsort"><a href="#pdqsort" class="headerlink" title="pdqsort"></a>pdqsort</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sortlearning<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math/bits&quot;</span><br><br><span class="hljs-string">&quot;golang.org/x/exp/constraints&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PDQsortV1</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span>]<span class="hljs-params">(v []T)</span></span> &#123;<br>recurseV1(v, bits.Len(<span class="hljs-type">uint</span>(<span class="hljs-built_in">len</span>(v))))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recurseV1</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span>]<span class="hljs-params">(v []T, limit <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> maxInsertion = <span class="hljs-number">24</span> <span class="hljs-comment">// slices of up to this length get sorted using insertion sort.</span><br><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// True if the last partitioning was reasonably balanced.</span><br>wasBalanced = <span class="hljs-literal">true</span><br>)<br><br><span class="hljs-keyword">for</span> &#123;<br>length := <span class="hljs-built_in">len</span>(v)<br><br><span class="hljs-comment">// Very short slices get sorted using insertion sort.</span><br><span class="hljs-keyword">if</span> length &lt;= maxInsertion &#123;<br>InsertionSort(v)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// If too many bad pivot choices were made, simply fall back to heapsort in order to</span><br><span class="hljs-comment">// guarantee `O(n log n)` worst-case.</span><br><span class="hljs-keyword">if</span> limit == <span class="hljs-number">0</span> &#123;<br>HeapSort(v)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !wasBalanced &#123;<br>limit--<br>&#125;<br><br><span class="hljs-comment">// Choose a pivot and try guessing whether the slice is already sorted.</span><br>pivotidx := choosePivotV1(v)<br><br><span class="hljs-comment">// Partition the slice.</span><br>mid := partitionv1(v, pivotidx)<br><br>left, right := v[:mid], v[mid+<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(left) &lt; <span class="hljs-built_in">len</span>(right) &#123;<br>wasBalanced = <span class="hljs-built_in">len</span>(left) &gt;= <span class="hljs-built_in">len</span>(v)/<span class="hljs-number">8</span><br>recurseV1(left, limit)<br>v = right<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>wasBalanced = <span class="hljs-built_in">len</span>(right) &gt;= <span class="hljs-built_in">len</span>(v)/<span class="hljs-number">8</span><br>recurseV1(right, limit)<br>v = left<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partitionv1</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span>]<span class="hljs-params">(v []T, pivotidx <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>pivot := v[pivotidx]<br>v[<span class="hljs-number">0</span>], v[pivotidx] = v[pivotidx], v[<span class="hljs-number">0</span>]<br>i, j := <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(v)<span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">for</span> i &lt;= j &amp;&amp; v[i] &lt; pivot &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">for</span> i &lt;= j &amp;&amp; v[j] &gt;= pivot &#123;<br>j--<br>&#125;<br><span class="hljs-keyword">if</span> i &gt; j &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>v[i], v[j] = v[j], v[i]<br>i++<br>j--<br>&#125;<br>v[j], v[<span class="hljs-number">0</span>] = v[<span class="hljs-number">0</span>], v[j]<br><span class="hljs-keyword">return</span> j<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 常见命令</title>
    <link href="/2022/05/24/git%20%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/24/git%20%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><ul><li>记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</li><li>能够更好的关注变更，了解到每个版本的变动是什么，方便检查改动的代码，预防事故；也便于随时切换到不同版本，回滚误删误改的问题代码。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><strong>本地版本控制</strong><ul><li>代表性工具：RCS。能够对本地代码实现版本控制。</li></ul></li><li><strong>集中式版本控制</strong><ul><li>代表性工具：SVN。提供一个远端服务器来维护代码版本，本地不保存代码版本，解决多人协作问题。</li><li>增量保存每次提交的 Diff，如果提交的增量中和远端现存的文件存在冲突，则需要本地提前解决冲突。</li><li><strong>优点</strong>：学习简单，方便操作。支持二进制文件，对大文件支持更友好。</li><li><strong>缺点</strong><ul><li>本地不存储版本管理的概念，所有提交都只能连上服务器后才可以提交。</li><li>分支的支持不够好，不利于大型项目团队合作。</li><li>用户本地不保存所有版本的代码，如果服务器故障，容易导致历史版本丢失</li></ul></li></ul></li><li><strong>分布式版本控制</strong><ul><li>代表性工具：Git。每个仓库都能记录版本历史，解决只有一个服务器保存版本的问题。</li><li>每次提交记录的都是完整的文件快照</li><li><strong>优点</strong><ul><li>分布式开发，每个库都是完整的提交历史，支持本地提交，强调个体</li><li>分支管理功能强大，方便团队合作，多人协同开发</li><li>校验和机制保证完整性，一般只添加数据，很少执行删除操作，不容易导致代码丢失。</li></ul></li><li><strong>缺点</strong><ul><li>相对于 SVN 更复杂，学习成本更高</li><li>对于大文件的支持不是特别好（git-lfs 工具可以弥补）</li></ul></li></ul></li></ul><h1 id="git-的使用"><a href="#git-的使用" class="headerlink" title="git 的使用"></a>git 的使用</h1><h2 id="初始化-git-仓库"><a href="#初始化-git-仓库" class="headerlink" title="初始化 git 仓库"></a>初始化 git 仓库</h2><p>进入目标文件中, 输入 git init, 初始化为 git 仓库</p><h2 id="常见-git-配置"><a href="#常见-git-配置" class="headerlink" title="常见 git 配置"></a>常见 git 配置</h2><ul><li><p>用户名配置</p><ul><li><p><code>git config --global user.name &quot;name&quot;</code></p></li><li><p><code>git config --global user.email name@***.com</code></p></li></ul></li><li><p>Instead of 替换</p><ul><li><p>替换 git 命令。比如，将 SSH 协议换成 HTTP 协议</p></li><li><p><code>git config --global url</code></p></li></ul></li><li><p>Git 命令别名配置</p><ul><li>可简化 Git 命令，</li><li><code>git config --global alias.cin &quot;commit --amend --no-edit&quot;</code>( 配置之后, cin 等价于 commit –amend –no-edit )</li></ul></li></ul><h2 id="Git-Remote-操作远程仓库"><a href="#Git-Remote-操作远程仓库" class="headerlink" title="Git Remote 操作远程仓库"></a>Git Remote 操作远程仓库</h2><ul><li><p>查看 Remote</p><ul><li>git remote -v</li></ul></li><li><p>添加 Remote</p><ul><li>git remote add origin_ssh <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;</a>:git&#x2F;git</li><li>git remote add origin_http <a href="https://github.com/git/git.git">https://github.com/git/git.git</a></li></ul></li><li><p>再输入 git remote -v</p><ul><li>origin_http      <a href="https://github.com/git/git.git">https://github.com/git/git.git</a> (fetch)<br>origin_http      <a href="https://github.com/git/git.git">https://github.com/git/git.git</a> (push)<br>origin_ssh       <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>:git&#x2F;git (fetch)<br>origin_ssh       <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;</a>:git&#x2F;git (push)</li></ul></li><li><p>输错名字可以输入 git remote rename &lt;旧名称&gt; &lt;新名称&gt; 更改名字</p></li><li><p>为同一个 Origin 设置不同的 Push 和 Fetch URL</p><ul><li>git remote set-url –add –push origin <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>:MY_REPOSITY&#x2F;git (更改 push 的 URL)</li></ul></li><li><p>SSH 免密配置</p><ul><li>SSH 可以通过公私钥的机制，将生成的公钥存放在服务端，从而实现免密访问</li><li>目前的 Key 有四种类型，分别是 dsa、rsa、ecdsa、ed25519。默认使用 rsa，但由于安全问题，不推荐使用 dsa 和 rsa，推荐使用 ed25519</li><li>配置方式：ssh-keygen -t ed25519 -C “<a href="mailto:&#x79;&#x6f;&#117;&#114;&#x5f;&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;">&#x79;&#x6f;&#117;&#114;&#x5f;&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#101;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d;</a>“ ，密钥默认存放在 ~&#x2F;.ssh&#x2F;id_ed25519.pub</li></ul></li></ul><h1 id="修改历史版本"><a href="#修改历史版本" class="headerlink" title="修改历史版本"></a>修改历史版本</h1><ul><li><p>commit –amend。可修改最近的一次 commit 信息，修改之后 <strong>commit id</strong> 会改变</p></li><li><p>rebase。如：git rebase -i HEAD~3。可实现对最近三个 commit 的修改：</p><ul><li><p>合并 commit </p></li><li><p>具体的 commit message</p></li><li><p>删除某个 commit</p></li></ul></li><li><p>filter –branch。指定删除所有提交中的某个文件或者全局修改邮箱地址等操作</p></li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="无法拉取代码"><a href="#无法拉取代码" class="headerlink" title="无法拉取代码"></a>无法拉取代码</h2><ul><li>免密认证没有配</li><li>配的是 SSH 免密配置，但使用的是 HTTP 协议访问，需要配置 Instead Of</li></ul><h2 id="Fetch-远端分支后，本地当前分支历史不变"><a href="#Fetch-远端分支后，本地当前分支历史不变" class="headerlink" title="Fetch 远端分支后，本地当前分支历史不变"></a>Fetch 远端分支后，本地当前分支历史不变</h2><ul><li>Fetch 会把代码拉取到本地的远端分支，但是不会合并到当前分支，所有当前分支历史没有变化</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>版本控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 注入</title>
    <link href="/2022/05/19/SQL%20%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/05/19/SQL%20%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><blockquote><p><strong>SQL 注入</strong> 主要是通过巧妙构造 SQL 查询语句，绕过防火墙的限制，获取网站后台的管理权限、 用户资料等信息。因 SQL 注入获取了诸多的网管权限，所以对网站有非常严重的影响，又因为其效率高，门槛低，目前仍然是危害最大的攻击类型之一。</p></blockquote><h2 id="SQL-注入的定义"><a href="#SQL-注入的定义" class="headerlink" title="SQL 注入的定义"></a>SQL 注入的定义</h2><p>对 SQL 注入定义的简单理解，就是由于程序员在编写代码时，在对用户输入端输入的数据并没有进行合法性的验证，从而使得该应用程序在 安全方面存在着很大的隐患，而黑客可以趁虚而入地利用这些漏洞，构建一些特殊的<strong>数据库查询</strong> 语句，并根据 Web 应用服务器返回的结果完成查询，获取用户登录信息等自己想要得知的结果，从而导致网站 <strong>权限被非法获取</strong>。</p><h2 id="SQL-注入攻击的原理"><a href="#SQL-注入攻击的原理" class="headerlink" title="SQL 注入攻击的原理"></a>SQL 注入攻击的原理</h2><p>SQL 注入漏洞是因开发者未对用户的 <strong>输入</strong> 进行 <strong>验证</strong> 和 <strong>过滤</strong>，使得攻击者趁机构造一系列 SQL 语句进入数据库，录后台，查询需要管理员权限的网站信息。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>​        假设网站中某页面接收用户输入后赋予其字符型参数 z，在后台 z 就作为 SQL 语句的查询条件参数，其后台通过“select * from table where colname&#x3D;‘z’”，即可枚举出数据库中列名为“z”的所有数据。假如黑客利用这一页面进行攻击，首先会猜测数据库中的表名是否为“user”，在对z 赋值的文本框中输入“1 or ‘0&lt;(select count (*) from admin) and 1’&#x3D;1’ ”。这里黑客使用“or”隔离了之前的逻辑判断，通过巧妙的 SQL 语句的构造，得出了判断 user 表是否为空的信息，如果该表非空说明该表存在，如果出现错误信息的提示则说明表不存在，攻击者可继续按照同样的方法猜测表名，直到猜对正确的表名，猜对之后，攻击者便可获取后台的权限。</p><h2 id="传统的-SQL-注入攻击技术"><a href="#传统的-SQL-注入攻击技术" class="headerlink" title="传统的 SQL 注入攻击技术"></a>传统的 SQL 注入攻击技术</h2><h3 id="逻辑查询技术"><a href="#逻辑查询技术" class="headerlink" title="逻辑查询技术"></a>逻辑查询技术</h3><p>数据库中常见的错误通常包括 <strong>逻辑错误</strong>、<strong>语法错误</strong> 以及 <strong>类型转换错误</strong>。因为数据库详细的错误提示会泄露大量的信息，攻击者往往先引起某种类型的数据库错误，再根据不同的数据库错误类型获取信息。比如，根据语法错误可获取错误提示中的参数信息，根据类型转换的错误提示，可获取表中数据，而根据逻辑错误的提示可获取元数据。</p><h3 id="联言查询技术"><a href="#联言查询技术" class="headerlink" title="联言查询技术"></a>联言查询技术</h3><p>SQL 查询中的 UNION 联言查询技术允许在原查询结果集中拼接新的 SELECT 查询以获取信息，若此时攻击者先设法使原查询中的 WHERE条件的部分的判断为假，便可使最终的结果集中只包含后一个攻击者构造的 SELECT 查询结果，这样最终显示的结果就是攻击者所构造的语句查询后显示的结果。</p><h3 id="SQL-盲注技术"><a href="#SQL-盲注技术" class="headerlink" title="SQL 盲注技术"></a>SQL 盲注技术</h3><p>在进行过一个 SQL 注入攻击后，通过判断攻击载荷前后的 <strong>Web 的不同响应的方式</strong> 来获取攻击者自己想要的信息，这一技术被称作基于响应的 SQL 盲注技术，这种盲注因一次注入只能判断出一位（真或假）的信息，因此又称作判断技术。基于响应的 SQL 盲注技术又可以分成 <strong>基于内容的盲注</strong> 和 <strong>基于时间的盲注</strong> 两种。前者是根据 Web 页面内容有所变化而判断 Web 应用中的信息和数据，而基于时间的 SQL 盲注则是根据 Web 页面的不同响应时间来推断出 Web 应用信息或者应用数据的具体内容</p><h2 id="新型的-SQL-注入技术"><a href="#新型的-SQL-注入技术" class="headerlink" title="新型的 SQL 注入技术"></a>新型的 SQL 注入技术</h2><h3 id="绕过-SQL-防注技术"><a href="#绕过-SQL-防注技术" class="headerlink" title="绕过 SQL 防注技术"></a>绕过 SQL 防注技术</h3><p>Web 应用为了能够成功阻止 SQL 注入攻击，通常在程序代码中部署 IDS 过滤器，或者 WAF 过滤器来进行有效防御。而通过一些类型转换、多种编码组合绕过以及大小写互换等方法可以绕过 SQL 注入过滤器，发动攻击。</p><ul><li><strong>类型转换</strong><br>    为了成功避过防注入的入侵检测系统，可以利用 SQL 中的一些字符，例如：<strong>or ‘swords’&#x3D; N ’swords’</strong>，大写的 N 告诉 mssql server 服务器字符串的类型为 nvarchar 类型，它不仅完成了类型转换的作用，而且不影响注入语句，可以成功地避过基于知识的模式匹配 IDS。</li><li><strong>多种编码组合</strong><br>    通过编码 <strong>改变字符特征</strong>，过滤器的黑名单便不能再成功匹配到原来的字符特征，例如用 HEX 绕过：<br>0x730079007300610064006D0069006E00<br>&#x3D;hex(sysadmin)<br>0x640062005F006F0077006E0065007200<br>&#x3D;hex(db_owner)<br>    通过这种绕过方式，一般的入侵检测系统都无法检测出来。而多种编码可以组合绕过，常用的可组合的编码如 BASE64、ASC、SQL、HEX、URL 编码等。</li><li><strong>大小写互换</strong><br>    在 SQL 注入攻击中，字母的大小写不同往往也会产生截然不同的效果，例如将查询语句中的select 可以写成 SelEct 来绕过过滤器，而将 union 可以写成 UnIoN 也可以成功避开入侵检测系统。</li><li><strong>利用特殊字符</strong><br>因为编译器的程序代码和编写应用程序代码不同而导致二者在处理特殊字符时也有所差异，非托管代码会把特殊字符当作结尾的字符串而不做处理，只需在不希望被屏蔽的字符前面加上 <strong>特殊字符的 URL 编码</strong>，就能实现特殊字符绕过过滤器，一般用来 <strong>绕过第三方防火墙软件</strong>。</li><li><strong>通过“+”拆解字符串绕过</strong><br>如 or ‘swords’ &#x3D; ‘sw’ +’ ords’；EXEC(‘IN’ + ’SERT INTO‘ + ’…..’)这样通过 + 号 <strong>将完整的字符拆解开</strong>，便可成功 <strong>绕过 IDS</strong>。当然，除了以上介绍的几种方法之外，还有运用注释语句绕过、利用中转工具绕过、运用字符串判断代替绕过等多种绕过方式，在具体运用的时候可以结合自己想要构造的 SQL 注入语句，以及所要绕过的 IDS 类型，灵活选取和运用</li></ul><h2 id="新型二阶-SQL-注入技术"><a href="#新型二阶-SQL-注入技术" class="headerlink" title="新型二阶 SQL 注入技术"></a>新型二阶 SQL 注入技术</h2><p>​        上述章节所论述的注入技术都是一阶 SQL 注入技术。在一阶 SQL 注入技术中，攻击者控制的数据会在程序内部突破风险值，进而可以任意注入操作命令，从注入载荷到获取数据都是在程序的同一位置。二阶 SQL 注入实现了在一个位置 <strong>先存储</strong>，再在另一个位置 <strong>触发攻击载荷</strong>，从而成功避过了大多数 IDS 仅在同一位置观察攻击响应的检测。</p><p>​        二阶 SQL 注入的第一个阶段的存储位置是在 服务器写磁盘的位置，一般存储在会话中、系统 文件中或者数据库中，此时攻击载荷的存储位置可能在数据库特定表的某个行或列中。</p><p>​        二次注入的关键是在于第二次构造，也就是触发阶段，第一次的 SQL 存储阶段，是为了第二次的构造做一个铺垫，第二次触发阶段才是真正的攻击。因此，针对存入数据库的 SQL二阶注入防御的方法就是要对已经使用过的数据进行过滤和检查，哪怕是已经使用过的或者是数据库中已经存在的数据。</p><p>​        一阶 SQL 注入容易被扫描工具发现，而二阶 SQL 注入更难被发现，通常要根据测试人员的经验，对系统出错位置的准确判断， 但应用的功能也在不断更新，因此单凭经验也并不能保证测试的正确，从这一点上来讲，二阶 SQL 注入的隐蔽性和危害性更大。</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>假设一个网站管理员的用户名为“admin”，密码为：“123456”，黑客注册了一个用户名：“admin’–”，密码为：“123”。</p><p>​        因为用户名中包含特殊字符，网站会自动进行转义，因此一阶 SQL 注入便无法通过。但是在数据库中，用户名仍然以“admin’–”的方式被储存。接下来就是黑客正真实施攻击的触发极端，他先修改用户名和密码。具体的修改过程为：先判断该用户是否为空，若用户名存在，再确认用户以前的密码是否正确，若正确，获取要修改的密码，获取后，最终密码修改成功。</p><p>​        因“–”在数据库作为注释，起到拒绝执行后面的语句的作用，而“admin”后面特殊字符中的单引号又与前面的’闭合，而原本后面的那个单引号被后置到了“–”之后，被其当作注释去掉了，所以，该黑客修改的其实是“admin”的密码。</p><blockquote><p>关于转义函数，我们需要重点关注：addslashes(),mysql_escape_string()和mysql_real_escape_string()。这几个函数，在参数插入数据库时会对特殊字符进行转义，但是保存在数据库中时还是原始格式内容。</p></blockquote><h2 id="Cookie-注入技术"><a href="#Cookie-注入技术" class="headerlink" title="Cookie 注入技术"></a>Cookie 注入技术</h2><p>​        当用户向服务器提交参数时，SQL 注入防火墙往往会先检查其中是否包含非法字符，若参数中包含非法字符则进行过滤，若参数合法则提交到后台，但通常的 SQL 注入防火墙往往只针对用户通过 POST 和 GET 方式提交给后台的参数进行过滤，而没有对通过 Cookie 方式提交的数据进行检查，因此，通过 Cookie 注入就可以成功绕过 SQL 注入防火墙。</p><h1 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h1><h2 id="检查变量数据类型和格式"><a href="#检查变量数据类型和格式" class="headerlink" title="检查变量数据类型和格式"></a>检查变量数据类型和格式</h2><p>​        SQL语句为where id&#x3D;{$id)这种形式，当 SQL 语句被执行之前检查确保变量 id 是 int 类型：当使用邮箱时，应确保其输入的变量为邮箱的正确形式，如果需要时间、电话等信息也是同样的道理。在执行 SQL 语句时，若其有固定的格式应严格按照其标准来要求，并且要严格检查其格式．对于 ID 号应严格要求在用户进行注册时 ID 号只能是数字，不能输入其他特殊符号。此时应该有一个 check_ID 的函数来进行统一的检查。<br>​        在 SQL Server 中，右击 Admin 表。点击设计一&gt;右击 ID一&gt;选择 CHECK 约束一&gt;点击添加写表达式为 (ID in (1，2，3，4，5，6，7，8，9))，此时，已成功对 ID 进行了约束。</p><h2 id="过滤特殊符号与语法关键字"><a href="#过滤特殊符号与语法关键字" class="headerlink" title="过滤特殊符号与语法关键字"></a>过滤特殊符号与语法关键字</h2><p>在Web应用程序中，有些符号是比较危险的，因此可以采用特殊符号过滤方法来处理无法确定的格式变量。</p><h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p>​        当相同类型 SQL 语句绑定变量时，SQL 文本变得一样，此时减少了程序硬解析的次数。这里相同类型 SQL 语句是指除 SQL 文本中对应的输入值不同外其他部分均相同</p><h2 id="参数化-SQL-语句"><a href="#参数化-SQL-语句" class="headerlink" title="参数化 SQL 语句"></a>参数化 SQL 语句</h2><p>​        参数化查询是指在当Web应用程序要访问数据库时，在需要填写ID和密码的地方使用参数传递值，当使用参数化查询，数据库不会立马对参数的内容进行处理。当数据库将SQL语句编译完毕后，参数指令才会运行。 攻击者想利用注入漏洞进行攻击，由于使用参数化查询。 就算参数中有攻击语句，程序也已编译完成。使用参数化 SQL 语句是 <strong>最为有效</strong> 的防止 SQL 注入漏洞的方法。</p><p><strong>例如：</strong></p><p>​        (1)适应@符号来表示参数，string sqlstr&#x3D;”SELECT*FROM Admin WHERE ID&#x3D;@ID AND PWD&#x3D;@PWD”。</p><p>​        (2)给SQL语句中的参数定义参数对象，用 SqlParameter 数组传递参数值：<br>SqlParameter[]para&#x3D;new SqlParameter[]{new SqlParameter(”@ID”，ID))<br>将查询语句中所需要的值传递给 SqlParameter 数组，再把值传递给cmd。</p><blockquote><p>摘自文献 </p><p>1]薛李滨, 潘瑜, 胡选攀,等. 新型SQL注入攻击技术研究[C]&#x2F;&#x2F; 2018第七届全国安全等级保护技术大会. 0.</p><p>[1]李玲, 任佳宁, 韩冰倩,等. 基于Web应用安全的SQL注入漏洞与防御[J]. 电脑编程技巧与维护, 2022(1):2.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>信息安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络攻击</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go中的函数与方法</title>
    <link href="/2022/05/06/go%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/06/go%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>一般形式：func ( 接收器类型 )  name( 参数 )  返回值类型{ }。</p><p>例如，定义结构体 type rect struct {    width, height int }</p><p>为 rect 定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *rect)</span></span> area() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> r.width * r.height<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rect)</span></span> perim() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*r.width + <span class="hljs-number">2</span>*r.height<br>&#125;<br><span class="hljs-comment">// 调用</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>     r := rect&#123;width: <span class="hljs-number">10</span>, height: <span class="hljs-number">5</span>&#125;<br>     <br>     rp := &amp;r<br>     fmt.Println(<span class="hljs-string">&quot;area: &quot;</span>, rp.area())<br>     fmt.Println(<span class="hljs-string">&quot;perim:&quot;</span>, rp.perim())<br>     <span class="hljs-comment">// 输出 area:  50 perim: 30</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>go 中的函数与其他编程语言在语法上大同小异，一般形式：func name( 参数 ) 返回值类型{ }</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    res := sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    fmt.Println(<span class="hljs-string">&quot;1+2 =&quot;</span>, res)<br>    <span class="hljs-comment">// 输出 1+2 = 3</span><br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet技术</title>
    <link href="/2022/05/03/JavaWeb-Servlet%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/05/03/JavaWeb-Servlet%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>Servlet 是一种 <strong>独立</strong> 于平台和协议的服务器端的 Java 应用程序，它 <strong>处理请求</strong> 的信息并将其 <strong>发送到客户端</strong>。而客户端可以提出请求并获得该请求的响应。Servlet 用于生成 <strong>动态</strong> 的 Web 页面。</p><h1 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h1><p>当 Web 服务器接收到一个 HTTP 请求时，会先判断请求内容，如果是静态网页数据，Web 服务器将自行处理，然后产生响应信息；如果涉及动态数据吗，Web 服务器将其转交给 Servlet 容器。</p><p>然后 Servlet 容器找到对应的处理该请求的 Servlet 实例来处理，并将结果送回 Web 服务器，由服务器传给用户端。</p><blockquote><p>针对同一个 Servlet，Servlet 容器会在第一次收到 HTTP 请求时建立一个 Servlet 实例，然后启动一个线程。当第二次收到 HTTP 请求时，不再建立相同的实例，而是启动第二个线程服务于请求。</p></blockquote><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>Servlet 的生命周期是指 Servlet 实例在创建之后响应客户端的请求直到销毁的全过程。生命周期在 Servlet 继承的类中定义如何被加载、初始化，以及它怎样接收请求、响应请求，提供服务。对应的方法为 init()、service() 和 destroy()。</p><p>Servlet 生命周期的各个阶段：</p><ul><li>实例化：Servlet 容器创建 Servlet 类的实例对象</li><li>初始化：容器调用 Servlet 的 init() 方法，通常会申请资源以便后续使用</li><li>服务：由容器使用以响应客户对 Servlet 的请求</li><li>销毁：在释放 Servlet 实例之前调用，通常会释放资源</li><li>不可用：释放内存中的容器</li></ul><h1 id="获取请求中的数据"><a href="#获取请求中的数据" class="headerlink" title="获取请求中的数据"></a>获取请求中的数据</h1><p>在 Servlet 类的请求处理方法(如 doPost 方法和 doGet方法)中，要想获取客户端请求中提交的数据，需要使用 HttpServletRequest 提供的方法：</p><ul><li>public String **getParameter(String name)**：获取指定名称的参数值。</li><li>public String[] **getParameterValues(String name)**：获取指定名称参数的所有值数组，适用于 <strong>一个参数名对应多个值</strong> 的情况，如页面表单中的复选框，多选列表提交的值。</li><li>public java.util.Enumeration **getParameterNames()**：返回一个包含请求消息中的 <strong>所有参数名</strong> 的 Enumeration 对象。通过遍历这个 Enumeration 对象，可以获取请求消息中所有的 <strong>参数名</strong>。</li><li>public  java.util.Map **getParameterMap()**：返回一个保存了请求消息中的所有参数名和值的 Map 对象。Map 对象的 key 是字符串类型的参数名，value 是这个参数所对应的 Object 类型的值数组。</li></ul><h1 id="重定向与请求分派"><a href="#重定向与请求分派" class="headerlink" title="重定向与请求分派"></a>重定向与请求分派</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>HTTPServletRequest 接口提供 sendRedirect() 方法生成 302 响应码和 Location 响应头，从而通知客户端去重新访问 Location 响应头中指定的 URL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRedirect</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p>其中，location 参数指定了重定向的 URL，可使用 <strong>绝对地址</strong> 和 <strong>相对地址</strong>，Servlet 容器会自动将相对 URL 转成绝对 URL 后，再生成 location 头字段。</p><p>sendRedirect() 方法不仅可以重定向到当前应用程序中的其他资源，还可以重定向到同一个容器中的其他应用程序中的资源，甚至是重定向到其他站点的资源。</p><h2 id="请求分派"><a href="#请求分派" class="headerlink" title="请求分派"></a>请求分派</h2><p>Servlet API 中定义了一个 RequestDispatcher 接口，俗称请求分派器。它定义了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forward</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">include</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br></code></pre></td></tr></table></figure><p><strong>forward() 方法</strong> 用于将 <strong>请求转发</strong> 到 RequestDispatcher 实例封装的资源；<strong>include() 方法</strong> 用于将 RequestDispatcher 实例封装的资源作为当前响应内容的一部分 <strong>包含进来</strong>。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li>请求分派只能将请求转发给同一个 web 应用中的其他组件；而重定向不仅可以定向到当前应用程序中的其他资源，也可以重定向到其他站点的资源上。</li><li>重定向访问结束后，浏览器地址栏中显示的 URL 会发生改变，变成重定向后的目标 URL；而请求转发后，浏览器的 URL 地址不变。</li><li>请求分派的发起者和被调用者之间共享相同的 request 实例和 response 实例，它们属于同一个“请求&#x2F;响应”过程；而重定向的发起者和调用者使用各自的 request 实例和 response 实例，它们各自属于独立的“请求&#x2F;响应”过程。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        二叉树是由 n（n&gt;&#x3D;0）个结点组成的有限集，它或者是空集（n&#x3D;0），或者由一个根结点及两颗互不相交的左子树和右子树的二叉树组成。<br>​<br>​        二叉树可以是空集，根可以有空的左子树或者右子树，亦或者左，右子树皆为空。</p><blockquote><p>​    二叉树的每个节点最多有两个子结点（度最大为2），不像普通的树可以有更多的子结点（子结点多于两个的树称为多路树）。</p><p>​     二叉树又称 <strong>二叉搜索树</strong>，使用一棵搜索树可以作为字典和优先队列。</p></blockquote><h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><ul><li>一棵深度为 k 且有 2^k-1 个结点的二叉树称为满二叉树。满二叉树的特点是，每一层的结点数都为 2，满二叉树中不存在度为 1 的结点。</li><li>非空满二叉树的叶节点数对于其分支结点数加 1。</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li>只有最下面的两层结点的度数可以小于 2，并且最下层上的结点是从左往右填充的。</li><li>满二叉树都是完全二叉树，但完全二叉树不一定都是满二叉树，满二叉树是完全二叉树的一个特例。</li><li>完全二叉树中，若某个结点没有左子树，则它一定没有右子树，即该结点必是叶子结点。</li></ul><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>​        二叉树的顺序存储结构是把二叉树的 <strong>所有结点按照一定的顺序存储</strong> 到一组包含 n 个存储单元的空间中。在二叉树的顺序存储结构中，只存储结点的值，不存储结点之间的逻辑关系，节点之间的逻辑关系由数组下标的顺序来体现。<br>​<br>​        在此存储结构中，不管给定的二叉树是不是完全二叉树，都将看作完全二叉树。即按照完全二叉树的层次次序（<strong>从上到下，从左到右</strong>），将结点依次存入数组中。<br>​<br>​        顺序存储结构存储完全二叉树时既简单又节省存储空间，但存储一般二叉树时会存储很多空结点，造成存储空间的浪费。</p><p><strong>特征</strong></p><p>​        由某结点的存储单元地址可以推出其父结点，左、右子树，兄弟结点的地址。</p><ul><li>第 n 个元素的 <strong>左子结点</strong> 为 2n+1</li><li>第 n 个元素的 <strong>右子节点</strong> 为 2n+2</li><li>第 n 个元素的 <strong>父节点</strong> 为 (n-1)&#x2F;2</li><li>当 n 为奇数时，第 n 个元素的 <strong>左兄弟结点</strong> 为 n-1</li><li>当 n 为偶数时，第 n 个元素的 <strong>左兄弟结点</strong> 为 n+1</li></ul><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>​        一般二叉树存储时通常采用链式存储结构（又称为二叉链表）。在此存储结构中，每个结点由 <strong>数据域</strong> 和 <strong>指针域</strong> 组成。二叉树每个结点的指针域有两个指针，一个指向左儿子，一个指向右儿子。<br>​<br>​        若二叉树为空，则根结点为 NULL。若结点的某个子树不存在，则对应的指针为空。具有 n 个结点的二叉树中，一共有 2n 个指针域，其中只有 n-1 个用来指示结点的左右子树，其余的 n+1 个指针域为空。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>​    我们可以用简单的递归算法来 <strong>按序</strong> 输出二叉树中的所有关键字。这种算法称为 <strong>中序遍历（inorder tree walk）</strong> 算法。类似的，还有 <strong>先序遍历（preorder tree walk）</strong> 和 <strong>后序遍历（postorder tree walk）</strong>。</p><ul><li>中序遍历：访问 <strong>根结点</strong> 的操作发生在遍历其 <strong>左右子树时</strong>（左-根-右）。</li><li>先序遍历：先访问 <strong>根节点</strong>，再遍历左右子树（根-左-右）。</li><li>后序遍历：先遍历左右子树，再访问 <strong>根节点</strong>（左-右-根）。</li></ul><h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p>​        插入和删除都会引起二叉树表示的动态集合的变化。因此，在插入和删除时，或者之后，需要对二叉树进行维护，保持二叉树的性质。相对于删除而言，插入数据后，维护二叉树比较简单。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>​        将一个新值 <strong>v</strong> 插入到一棵二叉树 <strong>T</strong> 的结点 <strong>z</strong> ，令 z.key &#x3D; v, z.left &#x3D; NULL, z.right &#x3D; NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">y = <span class="hljs-literal">NULL</span>;<br>x = T.root;<br><span class="hljs-keyword">while</span> (x != <span class="hljs-literal">NULL</span>)&#123;<br>    y = x;<br>    <span class="hljs-keyword">if</span> (z.key &lt; x.key) x = x.left;<br>    <br>    <span class="hljs-keyword">else</span> x = x.right;<br>    z.p = y;<br>&#125;<br><span class="hljs-comment">// 若树为空</span><br><span class="hljs-keyword">if</span> (y == <span class="hljs-literal">NULL</span>)&#123;<br>T.root = z;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> z.key &lt; y.key y.left = z;<br>    <br><span class="hljs-keyword">else</span> y.right = z<br></code></pre></td></tr></table></figure><p>​    简单来说，就是在插入是找到 v 应该在的位置，然后移动结点，令它插入后，仍然保持二叉树的性质。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>​        从一棵二叉树 T 中删除一个结点 z 有三种情况，最后一种最复杂：</p><ul><li>z <strong>无孩子结点</strong>：直接删除，并修改它的父节点，以 NULL 替换 z 即可。</li><li>z <strong>只有一个孩子</strong>：将这个孩子结点提升到 z 的位置，以它的孩子来替换 z。</li><li>z <strong>有两个孩子</strong>：<ol><li>从 z 的右子树（后继）中找 y，让 y 占据 z 的位置。</li><li>z 的左子树成为 y 的新左子树，z 的右子树成为 y 的新右子树。<ul><li>考虑到 y 是否为 z 的右孩子，还可细分为：<ol><li>若 z <strong>没有左孩子</strong>，可用其右孩子来替换。这个右孩子可以是 NULL，也可以不是。</li><li>若 z 仅有一个孩子，且是其 <strong>左孩子</strong> 时，直接用其左孩子替换 z。</li><li>若 z 同时有左孩子和右孩子。我们要查找 z 的后继 y，这个后继位于 z 的右子树中，并且 <strong>没有左孩子</strong>。</li><li>如果 y 是 z 的右孩子，那么直接替换 z ，仅留下 y 的右孩子。</li><li>若 y 位于 z 的右子树中，但不是 z 的右孩子。先用 y 的右孩子替换 y ，再用 y 替换 z。</li></ol></li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的定义及常用术语</title>
    <link href="/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <url>/2022/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>​    树是 N(N&gt;0)个结点的有限集合。其唯一关系具有下列属性：集合中存在唯一的一个结点，称为树的根，该结点没有前驱；除根结点外，其余结点分为 M(M&gt;&#x3D;0)个互不相交的集合，其中每一个集合都是一棵树，并称其为根的子树。</p><p>​    树(tree) 型结构是一种 <strong>一对多</strong> 的 <strong>非线性结构</strong>，它反映了数据元素之间的层次关系和分支关系。树形结构的特点是，<strong>一个数据结构可以有多个后继，但每个元素只能有唯一的前驱</strong>，<strong>最上层的元素（树根）没有前驱</strong>。</p><p>树结合了另外两种数据结构的优点，查找数据项的速度像有序数组一样快，插入数据项和删除数据项的速度也像链表一样。</p><h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><ul><li>度（degree）：一个结点含有的子树个数称为 <strong>度</strong> 。一棵树中结点度的最大值称为该树的度。度为 <strong>零(无子树)</strong> 的结点称为 <strong>叶子(leaf)</strong> 或者终端结点。度 <strong>不为零（含有子树）</strong> 的结点称为 <strong>分支节点</strong> 或者非终端结点</li><li>子节点 (child) 与父节点（parents）：树中结点的后继结点称为 <strong>子节点</strong> 。结点的前驱结点称为子节点的双亲结点或 <strong>父节点</strong>。同一父节点的子节点互称为 <strong>兄弟结点（sibling）。</strong></li><li>祖先：若树中挫折一个结点序列 k1, k2, k3, … , kj，使得 ki 是 k（i+1）的父亲（1&lt;&#x3D;i&lt;&#x3D;j，则称该结点序列是从 k1 到 kj 的一条 <strong>路径（path)</strong> 或者道路。若树中结点 k 到 ks 存在一条路径，则称 k 是 ks 的 <strong>祖先（Ancestor）</strong>，ks 是 k 的 <strong>子孙（Descendant）</strong>。一个结点的祖先是 **从根节点 **到它这条路径上经过的所有结点，而一个结点的子孙则是 <strong>以该结点为根</strong> 的子树中的 <strong>所有的结点</strong>。</li><li>层（level）：结点的层数从根开始算起，根结点的层数为 1 ，子节点的层数为父节点的层数加 1 。</li><li>高度&#x2F;深度：树中结点的最大层数称为树的 <strong>高度（Height）或深度（Depth）</strong>。</li><li>森林（Forest）：由 m（m&gt;&#x3D;0）棵 <strong>互不相交</strong> 的树的集合称为森林。若把 m 棵独立的数看作是子树并加上一个根节点，那么森林就变成了树，反之亦然。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2022/04/12/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/04/12/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是双指针"><a href="#什么是双指针" class="headerlink" title="什么是双指针"></a>什么是双指针</h1><p>在遍历对象时，有时需要使用两个相同方向或者相反方向的指针进行遍历，这个技巧称为双指针。</p><p>双指针又分为 <strong>左右指针(对撞指针)</strong> 和 <strong>快慢指针</strong> 。左右指针主要用于数组，快慢指针主要用于链表。</p><h2 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h2><p>左右指针一般用于有序数组，它将两个指针分别指向数组的开头及末尾，然后将其指向的元素进行交换，再将指针向中间移动一步，继续交换，直到这两个指针相遇。常用于二分查找法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最简单的二分算法, 这里假设传入的数组是有序的, 返回指定 target 的下标，若数组中不存在 target 这样的数，返回 -1。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 左指针从0开始</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 右指针从数组的末尾开始</span><br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 反转数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>        left++; right--;<span class="hljs-comment">// 左右指针同时向中间移动一位</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>与左右指针不同，快慢指针运动的方向是相同的。快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后。</p><blockquote><p>以下摘自力扣：</p></blockquote><blockquote><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><blockquote><p>采用快慢指针的思想：初始化一个快指针 fast 和一个慢指针 slow，fast 每次移动一步，而 slow 只当 fast 指向的值不等于 val 时才移动一步。</p><p><img src="https://pic.leetcode-cn.com/353657e00bf49ad5c6aeb8e97414d1d610083acdb580e7c2b0fe036a523129f5-4.gif" alt="4.gif"></p></blockquote></blockquote><p><strong>快慢指针的应用</strong></p><p>1、判断是否是环形链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> bool <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode *head)</span> &#123;<br>ListNode *slow, *fast;<br>slow = head; fast = head;<br><span class="hljs-keyword">while</span> (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;<br>        <span class="hljs-comment">// fast 指针移动的速度是 slow 的两倍, 如果存在环, 则快指针会追上慢指针, 表现为 fast == slow</span><br>fast = fast-&gt;next-&gt;next;<br>slow = slow-&gt;next;<br><span class="hljs-keyword">if</span> (fast ==  slow) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、找出未知长度单链表的中间节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 令 fast 的移动速度是 slow 的 2 倍，当 fast 指向末尾节点的时候，slow 正好就在中间</span><br><span class="hljs-keyword">while</span> (fast&amp;&amp;slow) &#123; <br><span class="hljs-keyword">if</span> (fast-&gt;next==NULL) <br><span class="hljs-keyword">return</span> slow -&gt;data; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fast-&gt;next!= NULL &amp;&amp; fast-&gt;next-&gt;next== NULL) <br><span class="hljs-keyword">return</span> (slow -&gt;data + slow -&gt;next-&gt;data)/<span class="hljs-number">2</span>; <br><span class="hljs-keyword">else</span> &#123; <br>fast= fast-&gt;next; <br>fast= fast-&gt;next; <br>slow = slow -&gt;next; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>equals() 与 hashCode()</title>
    <link href="/2022/04/09/equals()-%E4%B8%8E-hashCode()/"/>
    <url>/2022/04/09/equals()-%E4%B8%8E-hashCode()/</url>
    
    <content type="html"><![CDATA[<h1 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h1><p>在 equals() 方法中，若不是同一个对象，返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// equals() 源代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>   <span class="hljs-comment">// 如果两个String类型的对象内存地址相等直接返回true</span><br>       <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>       &#125;<br></code></pre></td></tr></table></figure><p>equals() 和 hashCode() 都不是 final 方法，都可以被重写(overwrite)。</p><p><strong>equals() 重写因遵循：</strong></p><ul><li>自反性：x.equals(x) 必须返回true。</li><li>对称性：x.equals(y )与 y.equals(x) 的返回值必须相等。</li><li>传递性：x.equals(y) 为 true，y.equals(z )也为true，那么 x.equals(z) 必须为true。</li><li>一致性：如果对象 x 和 y 在equals()中使用的信息都没有改变，那么 x.equals(y) 值始终不变。</li><li>非null：x 不是null，y 为null，则 x.equals(y) 必须为 false。</li></ul><h1 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h1><p>hashCode()在哈希表中起作用，如HashSet、HashMap等。当我们向哈希表(如 HashSet、HashMap 等) 中添加对象 object 时，首先调用 hashCode() 方法计算 object 的 <strong>哈希码</strong>，通过哈希码可以直接定位 object 在哈希表中的 <strong>位置</strong> (一般是哈希码对哈希表大小取余)。如果该位置没有对象，可以直接将 object 插入该位置；如果该位置有对象(可能有多个，通过链表实现)，则调用 equals() 方法比较这些对象与 object 是否相等，如果相等，则不需要保存 object；如果不相等，则将该对象加入到链表中。</p><p>因此，<strong>equals() 相等，则 hashCode() 必须相等。</strong>如果两个对象 equals() 相等，则它们在哈希表(如 HashSet、HashMap 等)中只应该出现一次；如果 hashCode() 不相等的话，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// hashCode() 源代码 </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>        <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">char</span> val[] = value;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>                h = <span class="hljs-number">31</span> * h + val[i];<br>            &#125;<br>            hash = h;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>重写 hashCode()</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String firstName;<br>    String lastName;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        h = <span class="hljs-number">31</span> * h + firstName.hashCode();<br>        h = <span class="hljs-number">31</span> * h + lastName.hashCode();<br>        h = <span class="hljs-number">31</span> * h + age;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>重写 equals()，最好也重写 hashCode()，否则使用 Map 时会出现一些问题。</strong></p><p>一个类如果覆写了<code>equals()</code>，就必须覆写<code>hashCode()</code>，并且覆写规则是：</p><ul><li>如果<code>equals()</code>返回<code>true</code>，则<code>hashCode()</code>返回值必须相等；</li><li>如果<code>equals()</code>返回<code>false</code>，则<code>hashCode()</code>返回值尽量不要相等。</li></ul><p>实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合类-Map</title>
    <link href="/2022/04/07/Java-%E9%9B%86%E5%90%88%E7%B1%BB-Map/"/>
    <url>/2022/04/07/Java-%E9%9B%86%E5%90%88%E7%B1%BB-Map/</url>
    
    <content type="html"><![CDATA[<h1 id="Map-映射-集合"><a href="#Map-映射-集合" class="headerlink" title="Map(映射) 集合"></a>Map(映射) 集合</h1><ul><li>用于保存具有映射关系的数据，元素是 键值(key-value) 对（Entry），key 不允许重复</li><li>本质 <strong>Map.Entry[]</strong></li><li>尽量不要修改作为 key 的可变对象的关键实例变量；自定义对象作为 key 必须覆写 hashCode 和 equals</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加元素</span><br>V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span><br></code></pre></td></tr></table></figure><blockquote><p>Java 类库为映射提供了两个通用的实现: HashMap 和 TreeMap。这两个类都实现了 Map 接口。散列映射对键进行散列，树映射根据键的顺序将元素组织为一个搜索树。散列或比较函数只应用于 <strong>键</strong> 。与键关联的值不进行散列或比较。</p></blockquote><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>存储键&#x2F;值关联的一个数据结构</li><li>key和value都允许为null。</li><li><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>当创建HashMap实例的时候，会通过指定的数组大小以及负载因子等参数创建一个空的数组，当在容器中添加元素的时候，首先会通过hash算法求得key的hash值，再根据hash值确定元素在数组中对应的位置，最后将元素放入数组对应的位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 HashMap 对象</span><br>HashMap&lt;Integer,String&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer,String&gt;();<br><span class="hljs-comment">//添加键值对</span><br>hashmap.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Google&quot;</span>);<br>hashmap.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Baidu&quot;</span>);<br>hashmap.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Taobao&quot;</span>);<br>System.out.println(hashmap.toString());<span class="hljs-comment">// &#123;1=Google, 2=Baidu, 3=Taobao&#125;</span><br>System.out.println(hashmap.get(<span class="hljs-number">3</span>));<span class="hljs-comment">//Taobao</span><br><br><span class="hljs-comment">// 输出 key 和 value</span><br><span class="hljs-keyword">for</span> (Integer i : hashmap.keySet()) &#123;<br>System.out.println(<span class="hljs-string">&quot;key: &quot;</span> + i + <span class="hljs-string">&quot; value: &quot;</span> + hashmap.get(i));<br>&#125;<span class="hljs-comment">//key: 1 value: Google key: 2 value: Baidu key: 3 value: Taobao</span><br><br> <span class="hljs-comment">// 返回所有 value 值</span><br><span class="hljs-keyword">for</span> (String value : hashmap.values()) &#123;<br><span class="hljs-comment">// 输出每一个value</span><br>System.out.print(value + <span class="hljs-string">&quot;, &quot;</span>);<br>&#125;<span class="hljs-comment">// Google, Baidu, Taobao, </span><br><br>hashmap.remove(<span class="hljs-number">3</span>);<br>System.out.println(hashmap);<span class="hljs-comment">// &#123;1=Google, 2=Baidu&#125;</span><br>hashmap.clear();<br>System.out.println(hashmap);<span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// JDK 1.8 HashMap 的 hash 方法的源码</span><br><span class="hljs-comment">static final int hash(Object key) &#123;</span><br><span class="hljs-comment">      int h;</span><br><span class="hljs-comment">      // key.hashCode()：返回散列值也就是 hashcode</span><br><span class="hljs-comment">      // ^ ：按位异或</span><br><span class="hljs-comment">      // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br><span class="hljs-comment">      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  */</span><br></code></pre></td></tr></table></figure><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul><li>HashTable 类与 HashMap 类的作用一样，实际上，接口也基本相同。与 Vector 类的方法一样，HashTable 方法也是同步的。</li></ul><h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><ul><li>弱散列映射</li><li>值不会在别处使用时就可以被垃圾回收的一个映射</li></ul><p>使用 WeakHashMap ，当某个键的最后一个引用已经消失，没有途径可以引用这个值的对象时，这个数据结构将与垃圾回收器一起删除键值对。</p><p>WeakHashMap 使用弱引用 (weak references) 保存键。WeakReference 对象将包含另一个对象的引用，在这里，就是一个散列表键。对于这种类型的对象，垃圾回收器采用一种特有的方式处理。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul><li>键有序的一个映射</li><li>TreeMap和HashMap一样实现的是Map接口，但两者的实现方式天差地别。HashMap的底层是hash表+单向链表的形式存储数据，TreeMap底层是通过红黑树存储数据。HashMap因为是基于散列表的实现，所以时间开销为O(1)，TreeMap的时间开销是O(lgn)。TreeMap的优势在于他是基于key值排序的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合类-Collection</title>
    <link href="/2022/04/05/Java-%E9%9B%86%E5%90%88%E7%B1%BB-Collection/"/>
    <url>/2022/04/05/Java-%E9%9B%86%E5%90%88%E7%B1%BB-Collection/</url>
    
    <content type="html"><![CDATA[<blockquote><p>java集合类包含在java.util包下<br>集合类存放的是对象的引用，而非对象本身。<br>集合类型主要分为Set(集)，List(列表)，Map(映射)。</p></blockquote><h1 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h1><p>​    在 Java 类库中，集合的基本接口是 Collection 接口。这个接口有两个基本方法：<code>boolean add(E element)</code> 和 <code>Iterator&lt;E&gt; iterator</code></p><p>​    <code>add</code> 方法用于向集合中添加元素。如果添加的元素改变了集合，则返回 true，如果集合没有发生变化就返回 false。例如，向集合中添加一个已存在的对象，那么这个请求就不会被接受，因为集合中不允许有重复的对象。</p><p>​    <code>iterator</code> 方法用于返回一个实现了 Iterator 接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</p><h2 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h2><p>Iterator 接口包含4个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt;<br>&#123;<br>E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span>;<br><span class="hljs-comment">// Iterator 接口中没有 add 方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过反复调用 next() 方法可以逐个 <strong>访问</strong> 集合中的 <strong>每个元素</strong> 。但是，如果到达了集合的末尾，next 方法将抛出一个 noSuchElementException。因此，需要在 <strong>调用 next 之前</strong> 调用 hasNext 方法。如果迭代器对象还有多个可以访问的元素，这个方法就返回 true 。如果想要查看集合中的所有元素，就请求一个迭代器，当 hasNext 返回一个 true 时就反复调用 next 方法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c= ...;<br>Iterator &lt;String&gt; iter = c.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext())&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> iter.next();<br>    <span class="hljs-comment">//do something with element</span><br>&#125;<br><span class="hljs-comment">//也可以用 for each 循环:</span><br><span class="hljs-keyword">for</span>(String element : c)&#123;<br>    <span class="hljs-comment">//do something with element</span><br>&#125;<br><span class="hljs-comment">// 标准类库中的任何集合都可以使用 for each 循环</span><br></code></pre></td></tr></table></figure><p>也可以不写循环, 而是调用 <code>forEachRemaining</code> 方法并提供一个 <code>lambda</code> 表达式。</p><p>​    iterator.forEachRemaining(element -&gt; do something with element);</p><blockquote><p>访问元素的顺序取决于集合的类型。如果迭代处理一个 ArrayList ，迭代器将从索引 0 开始，每迭代一次，索引值加 1。但如果访问 HashSet 中的元素，将会按照一种基本随机的顺序获得元素。虽然同样可以遍历所有元素，但无法预测访问的顺序。</p></blockquote><p>Iterator 接口的 remove 方法将会 <strong>删除</strong> 上次调用 <code>next</code> 时返回的元素。即，删除两个相邻的元素，不可以直接使用两行 remove。需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">iterator.remove();<br>iterator.next();<br>iterator.remove();<br></code></pre></td></tr></table></figure><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><ul><li>不记录元素的添加顺序，不允许元素重复的集合</li><li>尽量不要修改 Set 集合元素中 <strong>判断两个元素相等的方法用到的实例变量</strong> ，否则将会导致 Set 无法正确操作这些集合元素；Set 存储的对象必须覆写 hashCode 和 equals。</li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet是Set接口的一个子类，用于存储 <strong>没有重复元素</strong> 的一个无序集合, 它的 add 方法不允许增加重复的元素。</p><ul><li>可以存放 null，但只能存放一个 null 值。</li><li>HashSet 继承 AbstractSet，有两个重要的方法，其中 HashCode() 和 equals() 方法,当对象被存储到 HashSet 当中时，会调用 HashCode() 方法，获取对象的存储位置。</li><li>HashSet集合判断两个元素相等的标准是两个对象通过 equals 方法比较相等，并且两个对象的 hashCode() 方法返回值相等（若 hashCode 值相等但 equals()方法返回 false，HashSet 将在这个位置用链表来保存这些对象，并且，jdk 1.8 中，如果某位置碰撞的数量超过 8 就会将链表置为红黑树）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个 HashSet 对象</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br><span class="hljs-comment">//往 HashSet 中添加元素</span><br>set.add(<span class="hljs-string">&quot;a&quot;</span>);<br>set.add(<span class="hljs-string">&quot;1&quot;</span>);<br>set.add(<span class="hljs-string">&quot;b&quot;</span>);<br>set.add(<span class="hljs-literal">null</span>);<br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iter</span> <span class="hljs-operator">=</span> set.iterator();<br><br><span class="hljs-keyword">while</span> (iter.hasNext())&#123;<br>            System.out.println( iter.next());<br>        &#125;<br></code></pre></td></tr></table></figure><blockquote><p>hashCode() 方法用于返回字符串的哈希码。字符串对象的哈希码根据以下公式计算：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span>[<span class="hljs-number">0</span>]*<span class="hljs-number">31</span>^(n-<span class="hljs-number">1</span>) + s[<span class="hljs-number">1</span>]*<span class="hljs-number">31</span>^(n-<span class="hljs-number">2</span>) + ... + s[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></blockquote><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li>LinkedHashSet 是 <strong>HashSet</strong> 的子类 ，根据元素的 <strong>hashCode</strong> 值来决定元素的存储位置，同时使用链表维护元素 <strong>添加的次序</strong>。</li><li>只是 HashSet 底层用的 HashMap，而 LinkedHashSet 底层用的 LinkedHashMap。</li><li>LinkedHashSet 可以记住元素插入次序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>();<br><br>        set.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;e&quot;</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;LinkedHashSet存储值得排序为：&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Iterator</span> <span class="hljs-variable">iter</span> <span class="hljs-operator">=</span> set.iterator();iter.hasNext();)&#123;<br>            System.out.println(iter.next());<br>        &#125;<br><span class="hljs-comment">//LinkedHashSet存储值得排序为：a b c d e</span><br></code></pre></td></tr></table></figure><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><ul><li>SortedSet是一个接口，里面（只有TreeSet这一个实现可用）的元素是有序集。</li><li>保证迭代器按照元素递增顺序遍历的集合，可以按照元素的自然顺序进行排序， 或者按照创建有序集合时提供的 Comparator进行排序</li></ul><h4 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h4><ul><li>NavigableSet 接口（SortedSet 的子接口）的实现类，元素处于 <strong>排序</strong> 状态，是一个有序集合</li><li>根据 <strong>红黑树</strong> 结构确定元素的存储位置</li><li>TreeSet 支持两种排序方法：自然排序（默认）和定制排序</li><li>TreeSet 集合判断两个元素相等的标准：元素的 <code>compareTo(Object obj)</code> 方法或 Comparator 对象的 <code>compare(T o1, T o2)</code> 方法的返回值为 0</li><li>只能添加同一种类型的对象（需要比较大小），否则会引发 ClassCastException 异常</li><li>当需要把一个对象放入 TreeSet 中，重写该对象对应类的 equals() 方法时，应保证该方法与<code>compareTo(Object obj)</code> 方法有一致的结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TreeSetTest.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">parts</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Item&gt;();<br>        parts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;Toaster&quot;</span>,<span class="hljs-number">1234</span>));<br>        parts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;Widget&quot;</span>,<span class="hljs-number">4562</span>));<br>        parts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;Modem&quot;</span>,<span class="hljs-number">9912</span>));<br>        parts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-number">8888</span>));<br>        System.out.println(parts);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出</span><br><span class="hljs-comment">[[description=Toaster,partNumber=1234], [description=Widget,partNumber=4562], [description=Apple,partNumber=8888], [description=Modem,partNumber=9912]]</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-keyword">var</span> sortByDescription=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Item&gt;(Comparator.comparing(Item::getDescription));<br><br>        sortByDescription.addAll(parts);<br>        System.out.println(sortByDescription);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出[[description=Apple,partNumber=8888], [description=Modem,partNumber=9912], [description=Toaster,partNumber=1234], [description=Widget,partNumber=4562]]</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> partNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Item</span><span class="hljs-params">(String aDescription, <span class="hljs-type">int</span> aPartNumber)</span> &#123;<br>        description = aDescription;<br>        partNumber = aPartNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[description=&quot;</span> + description + <span class="hljs-string">&quot;,partNumber=&quot;</span> + partNumber + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object otherObject)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == otherObject) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (otherObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (getClass() != otherObject.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Item) otherObject;<br>        <span class="hljs-keyword">return</span> Objects.equals(description, other.description) &amp;&amp; partNumber == other.partNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(description, partNumber);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Item other)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Integer.compare(partNumber, other.partNumber);<br>        <span class="hljs-keyword">return</span> diff != <span class="hljs-number">0</span> ? diff : description.compareTo(other.description);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>自然排序:</strong></p><ul><li>要求添加的对象的类必须实现 Comparable 接口</li><li>调用集合元素的 <code>compareTo(Object obj)</code> 方法来比较元素之间的大小关系，然后将集合元素按升序排列</li><li>java.lang.Comparable 接口：<code>int compareTo(T o)</code>：如果该对象小于、等于或大于指定对象，则分别返回负整数、0 或正整数</li></ul><p><strong>定制排序:</strong></p><ul><li>在创建 TreeSet 集合对象时，提供一个 Comparator 对象（比较器）与该 TreeSet 集合关联，由该 Comparator 对象负责集合元素的排序逻辑 <code>new TreeSet(Comparator c)</code></li><li>java.util.Comparator 接口：<code>int compare(T o1, T o2)</code>：如果第一个参数小于、等于或大于第二个参数，则分别返回负整数、0 或正整数</li></ul><h2 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h2><ul><li>记录元素的添加顺序，允许元素重复的集合，<strong>列表</strong></li><li>默认按元素的添加顺序设置元素的索引</li></ul><p><strong>List</strong> 是一个有序集合 (ordered collection)。元素会增加到容器中的特定位置。可以采用两种方式访问元素：迭代器访问 或 使用一个整数索引来访问。后者又称为 <em><strong>随机访问（random access）</strong></em>，因为它可以以任意顺序访问元素。与之不同，使用迭代器访问时，必须顺序地访问元素。</p><p>​    List 接口定义了多个用于随机访问的方法：</p><p>​    void add(int index, E element)</p><p>​    void remove(int index)</p><p>​    E get(int index)</p><p>​    E set(int index, E element)</p><p><strong>ListIterator</strong> 接口是一个 Iterator 的一个子接口，常用于遍历集合的元素 。它定义了一个方法用于在迭代器前面增加一个元素：</p><p>​    void add(E element)</p><blockquote><p>ArrayList 和 LinkedList 实现类都是 List 接口和 RandomAccess 接口的实现类，查询元素较快。</p><p>使用 initialCapacity 参数来设置该数组的长度，并且会自动增加（默认为 10）。其中，ArrayList 以 1.5 倍的方式扩容，Vector 以 2 倍的方式扩容。</p></blockquote><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul><li>Vector 类也是基于数组实现的队列，代码与ArrayList非常相似。</li><li>Vector 类的所有方法都是同步的，线程安全，但执行效率低。</li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li>ArrayList 是一个可以动态增长和缩减的一个索引序列</li><li>集合中元素被访问的顺序取决于集合的类型。</li><li>如果对ArrayList进行访问，迭代器将从索引0开始，每迭代一次，索引值加1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>arrayList.add(<span class="hljs-string">&quot;a&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;b&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-comment">//添加重复值</span><br>arrayList.add(<span class="hljs-string">&quot;a&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;d&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;e&quot;</span>);<br><span class="hljs-comment">//添加null</span><br>arrayList.add(<span class="hljs-literal">null</span>);<br><br>System.out.println(<span class="hljs-string">&quot;arrayList的输出顺序为:&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;<br>System.out.println((i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;:&quot;</span> +arrayList.get(i));<br>        &#125;<br><span class="hljs-comment">//输出 1:a 2:b 3:c 4:a 5:d 6:e 7:null</span><br></code></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li>LinkedList 是一个可以在任何位置高效插入和删除的一个有序序列。</li><li>基于<strong>双向链表</strong>的 List、Deque 接口的实现类，添加删除元素比较快，读取效率低于ArrayList，插入效率高。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList &lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>linkedList.add(<span class="hljs-string">&quot;a&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;b&quot;</span>);<br><br>linkedList.add(<span class="hljs-string">&quot;c&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;d&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;e&quot;</span>);<br>linkedList.add(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;2&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;linkedList的输出顺序是:&quot;</span> + linkedList.toString());<br><br>linkedList.push(<span class="hljs-string">&quot;f&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;push后，linkedList的元素顺序:&quot;</span> + linkedList.toString());<br><br>linkedList.pop();<br>System.out.println(<span class="hljs-string">&quot;pop后，linkedList的所剩元素:&quot;</span> + linkedList.toString());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">linkedList的输出顺序是:[a, b, 2, c, d, e]</span><br><span class="hljs-comment">push后，linkedList的元素顺序:[f, a, b, 2, c, d, e]</span><br><span class="hljs-comment">pop后，linkedList的所剩元素:[a, b, 2, c, d, e]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="ListIterator-接口"><a href="#ListIterator-接口" class="headerlink" title="ListIterator 接口"></a>ListIterator 接口</h4><p>链表与泛型集合(比如 Collection 和 Iterator 接口)之间有一个重要的区别。链表是一个 <strong>有序集合</strong> ，每个对象的位置十分重要。LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到 <strong>链表的中间</strong> 。由于迭代器描述了集合中的位置，所以这种依赖于位置的 add 方法将由迭代器负责。集合类库提供了一个子接口 ListIterator (Iterator 接口中没有 add 方法, 因在 Set 数据类型中，元素是无序的，而只有对自然有序的集合使用迭代器添加元素才有实际意义。)，其中包含 add 方法：</p><p>​    interface ListIterator<E> extends Iterator<E></p><p>​    {</p><p>​        void add(E element);</p><p>​        ……</p><p>}</p><p>ListIterator 接口有两个方法，可以用来反向遍历链表：<strong>E previous()</strong> 和 <strong>boolean hasPrevious()</strong> 。</p><p>与 next 方法一样，previous 方法返回越过的对象。</p><p>LinkedList 类的 ListIterator 方法返回了一个实现了 ListIterator 接口的迭代器对象。</p><p>​    ListIterator<String> iter &#x3D; staff.listIterator();</p><p>add 方法在迭代器位置之前添加一个新对象。例如，下面的代码将越过链表中的第一个元素，在第二个元素之前添加 “Juloet”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">staff</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>staff.add(<span class="hljs-string">&quot;Amy&quot;</span>);<br>staff.add(<span class="hljs-string">&quot;Bob&quot;</span>);<br>staff.add(<span class="hljs-string">&quot;Carl&quot;</span>);<br>ListIterator&lt;String&gt; iter = staff.listIterator();<br>iter.next(); <span class="hljs-comment">// 越过第一个元素</span><br>iter.add(<span class="hljs-string">&quot;Juliet&quot;</span>);<br>System.out.println(staff.toString());<br><span class="hljs-comment">// 输出 [Amy, Juliet, Bob, Carl]</span><br></code></pre></td></tr></table></figure><p>当调用 add 时，新添加的元素将变成链表的新表头。当迭代器越过最后一个元素时（hasNext 返回 false，添加的将成为列表的新表尾。如果链表有 n 个元素，会有 n+1 个位置可以添加新元素。这些位置与迭代器的 n+1 个可能的位置相对应。</p><blockquote><p>链表不支持快速随机访问。如果要查看链表中的第 n 个元素，必须从头开始，越过 n-1 个元素。</p><p>但是 LinkedList 类提供了一个用来访问某个特定元素的 get 方法(效率不高)：</p><p>LinkedList<String> list &#x3D; … ;</p><p>String obj &#x3D; list.get(n);</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 常用命令</title>
    <link href="/2022/04/02/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/04/02/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="启动Redis服务端"><a href="#启动Redis服务端" class="headerlink" title="启动Redis服务端"></a><strong>启动Redis服务端</strong></h1><ul><li>redis-server</li></ul><h1 id="启动Redis客户端"><a href="#启动Redis客户端" class="headerlink" title="启动Redis客户端"></a><strong>启动Redis客户端</strong></h1><ul><li>redis-cli</li><li>redis-cli –raw<ul><li>支持中文的启动方式</li></ul></li></ul><h1 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a><strong>Redis基本操作</strong></h1><ul><li>ping</li><li>测试与redis服务器是否联通, 若联通, 返回 pong </li><li>select (选择数据库进入)<ul><li>可选 0 ~ 15 </li><li>如, select 0 即进入 0 号数据库</li><li>登录Redis客户端后, 若没有做 select 操作, 默认选择 0 号数据库</li></ul></li></ul><h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><ul><li>Redis 保存的数据都是按照 <strong>键值对</strong> 来保存的</li><li><strong>键</strong> 的数据类型都是字符串</li><li><strong>值</strong> 的数据类型有以下五种<ul><li>字符串 (string)</li><li>哈希 (hash)</li><li>列表 (list)</li><li>无序集合 (set)</li><li>有序集合 (zset)</li></ul></li></ul><h1 id="字符串（string）操作"><a href="#字符串（string）操作" class="headerlink" title="字符串（string）操作"></a>字符串（string）操作</h1><p><strong>string</strong> 是 redis 最基本的类型，它是一种安全的二进制字符串。一个 key 对应一个 value。value 的最大值是 <strong>512M</strong></p><h2 id="添加修改值"><a href="#添加修改值" class="headerlink" title="添加修改值"></a>添加修改值</h2><ul><li>set 键 值 <ul><li>如: set user1 aaa 。 意为设置一个名为 user1 的键,  其值为 aaa</li></ul></li><li>setex 键  过期时间 值<ul><li>过期时间单位为秒</li><li>如: setex user2 3 bbb 。意为设置一个名为 user2 的键，值为 bbb ，过期时间为 3 秒。</li></ul></li><li>mset 键1 值1 键2 值2<ul><li>同时添加多个键值对</li><li>如：mset user3 ccc user4 ddd user5 eee</li></ul></li><li>追加键值<ul><li>append 键 值</li><li>如 ：append user1 haha 。给user1键的 <strong>值</strong> 追加 ‘haha’  , 返回值即为值的大小。</li></ul></li></ul><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><ul><li>get 键<ul><li>如：get user1 。获取 user1 键的值。 输出为 aaahaha</li><li>不存在的键，get 后会返回 nil</li></ul></li><li>mget 键1 键2 键n …<ul><li>获取多个值。如 mget user1 user2 user3。</li></ul></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li>del 键1 键2 键n …<ul><li>如: del user1 user2 user3 。 删除 user1, user2, user3 键。</li><li>删除键会连值一起删去。</li></ul></li></ul><h1 id="键相关操作"><a href="#键相关操作" class="headerlink" title="键相关操作"></a>键相关操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p>keys 键名</p><ul><li><p>查找对应的键， 若存在，返回查找的键名， 若不存在，返回空。</p></li><li><p>可以使用 keys * 查看所有键。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">mset user1 aaa user2 bbb user3 ccc<br>keys user1<span class="hljs-regexp">//</span>输出 user1<br>keys user10 <span class="hljs-regexp">//</span>无输出<br>keys *<span class="hljs-regexp">//</span>输出所有键, 即 user1 user2 user3 。同 keys <span class="hljs-string">&#x27;*&#x27;</span><br>keys *s*<span class="hljs-regexp">//</span>输出名称包含s的键, 即 user1 user2 user3 。同keys <span class="hljs-string">&#x27;*s*&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="判断键是否存在"><a href="#判断键是否存在" class="headerlink" title="判断键是否存在"></a>判断键是否存在</h2><ul><li>exists 键名<ul><li>若存在，则返回1；不存在，则返回0</li><li>exists user1。返回1</li></ul></li></ul><h2 id="查看键对应的值类型"><a href="#查看键对应的值类型" class="headerlink" title="查看键对应的值类型"></a>查看键对应的值类型</h2><ul><li>type 键名<ul><li>如：type user1。返回string。</li></ul></li></ul><h2 id="设置键的过期时间"><a href="#设置键的过期时间" class="headerlink" title="设置键的过期时间"></a>设置键的过期时间</h2><ul><li>expire 键名 秒数<ul><li>为已有的键设置过期时间。与 setex 的区别在于，setex 是在创建键时设置的，而expire则可以为已有的键设置，却不能创建键。</li><li>若存在这个键名，则 expire 返回 1 ，否则返回 0 。</li><li>如：expire user1 10 。 返回1 ，10秒后，输入 keys * ，发现输出的键名无 user1 。</li></ul></li></ul><h2 id="查看键的有效时间"><a href="#查看键的有效时间" class="headerlink" title="查看键的有效时间"></a>查看键的有效时间</h2><ul><li>ttl 键名<ul><li>返回值大于0，代表存在有效时间，且 返回的值即为剩余有效时间，单位：秒。</li><li>返回值为 -1 ，表示永远有效。</li><li>返回值为 -2 ， 表示键不存在</li></ul></li></ul><h1 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 (hash)"></a>哈希 (hash)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>hash 用于存储 “键值对” 的集合;</li><li>每个 hash 中的键可以理解为字段 (field), 一个字段 (field) 对应一个值 (value) .</li><li>hash 中值 (value) 类型为**字符串(string)**。</li><li>同一个 hash 中字段名不可重复。</li></ul><h2 id="添加值"><a href="#添加值" class="headerlink" title="添加值"></a>添加值</h2><ul><li>hset 键 字段 值<ul><li>如：hset huser1 name tom 。添加一个键 ’huser1‘ ，字段为 ’name‘ ， 值为 ’tom‘ 。</li><li>使用 type huser1 可发现, 返回值为 hash</li><li>输入key *  ，可发现键中多了huser1。</li></ul></li></ul><h2 id="添加多个值"><a href="#添加多个值" class="headerlink" title="添加多个值"></a>添加多个值</h2><ul><li>hmset 键 字段1 值1 字段2 值2 …<ul><li>hmset huser2 name mary sex female (添加一个 humer2 键,  带有2个字段)</li></ul></li></ul><h2 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h2><ul><li>hkeys 键<ul><li>获取指定键的所有 <strong>字段名</strong></li><li>如：hkeys huser1。返回 name 。hkeys huser2 。返回 name sex。</li></ul></li></ul><h2 id="获取字段的值"><a href="#获取字段的值" class="headerlink" title="获取字段的值"></a>获取字段的值</h2><ul><li>hget 键 字段名<ul><li>获取字段对应的值</li><li>如： hget huser1 name。输出 tom 。</li></ul></li></ul><h2 id="获取多个字段的值"><a href="#获取多个字段的值" class="headerlink" title="获取多个字段的值"></a>获取多个字段的值</h2><ul><li>hmget 键 字段1 字段2 …<ul><li>如: hmget huser2 name sex 。输出 mary female。</li></ul></li></ul><h2 id="获取所有字段的值"><a href="#获取所有字段的值" class="headerlink" title="获取所有字段的值"></a>获取所有字段的值</h2><ul><li>hvals 键名<ul><li>如：hvals huser2 。输出 mary female。</li></ul></li></ul><h2 id="输出所有字段的名及值"><a href="#输出所有字段的名及值" class="headerlink" title="输出所有字段的名及值"></a>输出所有字段的名及值</h2><ul><li>hgetall 键<ul><li>如：hgetall huser2。输出 name Mary sex female。</li></ul></li></ul><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><ul><li>hdel 键名 字段名<ul><li>如：hdel huser2  sex。输出  1，删除成功；再次输入hdel huser2 sex，输出 0 ，意为找不到此字段。</li><li>删除键中的最后一个字段, 键也会删除。</li><li>只能删除字段，不能删除键，想删除键须用 <strong>del</strong> 。</li></ul></li></ul><h1 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h1><ul><li>列表中每个键有多个值</li><li>列表可以从左侧添加值，也可以从右侧添加值</li><li>又称双端队列</li></ul><h2 id="添加值-1"><a href="#添加值-1" class="headerlink" title="添加值"></a>添加值</h2><ul><li>从列表左侧添加值<ul><li>lpush 键名 值1 值2 …<ul><li>如:  lpush luser1 aa 。从键 ’luser1‘ 列表的左侧加入值 ’aa’ 。</li><li>自动创建键名，若键名已存在，且为 list 类型，则添加值，并返回列表中当前存在的值的数量；若键名存在，但不是list类型，则报错。</li><li>若插入多个值, 如: lpush luser1 1 2 3 , 则后一个值在列表的靠前位置, 即 3 在列表开头, 然后是 2 ,再然后是 1 。</li></ul></li></ul></li><li>从列表右侧添加值<ul><li>rpush 键名 值1 值2 …<ul><li>如：rpush luser1 bb 。从键 ’luser1‘ 列表的右侧加入值 ’bb’。</li><li>同样可以自动创建键名，若键名已存在，且为 list 类型，则添加值，并返回列表中当前存在的值的数量；若键名存在，但不是list类型，则报错。</li><li>如：rpush luser1 cc dd。返回值为4，即列表中当前存在的值的数量。</li></ul></li></ul></li></ul><h2 id="插入值"><a href="#插入值" class="headerlink" title="插入值"></a>插入值</h2><ul><li>linsert 键 before 或者 after 值<ul><li>在指定的值前面或后面插入新值</li><li>如: linsert luser1 before cc 11 。在 cc 前面插入值 11 。</li><li>linsert luser1 after cc 22 。在 cc 后面插入值 22 。</li></ul></li></ul><h2 id="获取值-1"><a href="#获取值-1" class="headerlink" title="获取值"></a>获取值</h2><ul><li>lrange 键名 start stop<ul><li>start 代表开始索引</li><li>stop代表结束索引</li><li>第一个值的索引为 0 ，最后一个值的索引为 -1 。</li></ul></li></ul><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lrange</span> luser1 <span class="hljs-number">0</span> <span class="hljs-number">-1</span> // 获取 luser1 列表中的所有值<br><span class="hljs-keyword">lrange</span> luser1 <span class="hljs-number">2</span> <span class="hljs-number">-1</span> // 从第三个元素开始获取到最后一个值<br></code></pre></td></tr></table></figure><h2 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h2><ul><li>lset 键名 索引 值<ul><li>如： lset luser1 1 china。 把 luser1 键的第二个元素改为china（修改最后一个元素，索引值改为 -1 即可）。</li></ul></li></ul><h2 id="删除值"><a href="#删除值" class="headerlink" title="删除值"></a>删除值</h2><ul><li>lrem 键名 count 值<ul><li>count &#x3D; 0 ,删除指定的所有值。</li><li>count &lt; 0 , 从右往左删除指定数量的值。</li><li>count &gt; 0 , 从左往右删除指定数量的值。</li></ul></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">lrem luser1 -<span class="hljs-number">1</span> aa <span class="hljs-regexp">//</span>从右往左数, 删除一个 aa<br>lrem luser1 <span class="hljs-number">0</span> aa<span class="hljs-regexp">//</span>删除所有 aa <br></code></pre></td></tr></table></figure><h1 id="无序集合-set"><a href="#无序集合-set" class="headerlink" title="无序集合(set)"></a>无序集合(set)</h1><ul><li>不关注顺序</li><li>值不允许重复</li></ul><h2 id="添加值-2"><a href="#添加值-2" class="headerlink" title="添加值"></a>添加值</h2><ul><li>sadd 键名 值1 值2 值3 <ul><li>如 : sadd suser1 aa bb cc 。给一个名为 suser1 的键添加值 ’aa‘ ， ’bb‘ ，’cc‘， 若无此键，则建立一个新的；若有，但不是 set 类型 ，报错，若是 set 类型，则加入集合内（重复值无法加入），返回值为成功加入集合的值的数量。</li><li>集合里不允许有重复值。</li><li>集合里的值不能修改，只能添加和删除。</li><li>值的类型为 string。</li></ul></li></ul><h2 id="删除值-1"><a href="#删除值-1" class="headerlink" title="删除值"></a>删除值</h2><ul><li>srem 键名 值名<ul><li>如：srem suser1 cc。删除 suser1 键指定的值</li></ul></li></ul><h2 id="获取值-2"><a href="#获取值-2" class="headerlink" title="获取值"></a>获取值</h2><ul><li>smembers 键名<ul><li>如：smembers suser1。返回键 suser1 的所有值</li></ul></li></ul><h1 id="有序集合-zset"><a href="#有序集合-zset" class="headerlink" title="有序集合(zset)"></a>有序集合(zset)</h1><ul><li>集合里不允许有重复的值</li><li>有序集合里的值只能添加和删除，不能修改</li><li>有序集合中 <strong>值(value)</strong> 的类型为 <strong>字符串(string)</strong></li><li>每个值都会关联一个 <strong>分数(score)</strong> , 可以为负数, 通过 score 将值从小到大排序</li></ul><h2 id="添加值-3"><a href="#添加值-3" class="headerlink" title="添加值"></a>添加值</h2><ul><li>zadd 键名 score1 值1 score2 值2<ul><li>如: zadd zuser1 1 aa 3 dd 5 ee 2 cc 。返回值为成功添加的值的数量，且添加的值会自动排序。</li></ul></li></ul><h2 id="删除值-2"><a href="#删除值-2" class="headerlink" title="删除值"></a>删除值</h2><p><strong>通过键</strong></p><ul><li>zrem 键 zuser1 dd，删除 zuser1 的 dd ，删除成功则返回 1 。</li></ul><p><strong>通过 score 删除值</strong></p><ul><li>zremrangebyscore 键名 min max<ul><li>min 为删除 score 的最小值，max 为要删除 score 的最大值。</li><li>如：zremrangebyscore zuser1 0 10，删除 score 为 0 至10 之间的值，输出删除掉的值的个数。</li><li>删除所有值后，键将自动删除。</li></ul></li></ul><h2 id="获取值-3"><a href="#获取值-3" class="headerlink" title="获取值"></a>获取值</h2><ul><li>zrange 键名 start stop [withscores]<ul><li>start 从 0 开始, 最后一个元素的索引为 -1</li><li>withscores 代表同时获取 score<ul><li>如 : zrange zuser1 0 -1 withscores 。获取 zuser1 的所有元素，并获取 score。输出aa<br>1 cc 2 dd 3 ee 5</li></ul></li></ul></li><li>通过 score 获取值<ul><li>zrangebyscore 键名 min max<ul><li>min 代表 score 的起始值，max代表 score 的结束值。<ul><li>zrangebyscore zuser1 2 6 ，获取 score 从 2 到 6 的值，输出 cc dd ee 。</li></ul></li></ul></li></ul></li></ul><h2 id="通过值获取score"><a href="#通过值获取score" class="headerlink" title="通过值获取score"></a>通过值获取score</h2><ul><li>zscore 键名 值<ul><li>如： zscore zuser1 dd ，获取键 zuser1 的值 dd 的 score。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 8 新特性</title>
    <link href="/2022/03/29/java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/03/29/java-8-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Java 8 新增了许多新特性，这里主要列举其中几个重要的。</p></blockquote><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p> <strong>Lambda</strong> 表达式是推动 Java 8 发布的最重要新特性。是继泛型(<code>Generics</code>)和注解(<code>Annotation</code>)以来最大的变化。Lambda 表达式由<strong>参数列表</strong>、<strong>箭头</strong>（<code>-&gt;</code>）和 <strong>Lambda 主体</strong>组成。它是一种匿名函数，java 8 允许把函数作为参数传递进方法中。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。lambda表达式的特征:</p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号()，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号{}。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li></ul><blockquote><p>在 Lambda 主体中引用的局部变量必须使用 <code>final</code> 修饰或不被后面的代码修改（类似匿名内部类）, 不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>Runnable 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();<br><span class="hljs-comment">//输出 It&#x27;s a lambda function!</span><br><br><span class="hljs-comment">//语句等价于</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;It&#x27;s a lambda function!&quot;</span>);<br>            &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><p><strong>自定义接口:</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LambdaInterface</span> &#123;<br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEg</span><span class="hljs-params">()</span> &#123;<br>        lambdaInterfaceDemo(()-&gt; System.out.println(<span class="hljs-string">&quot;自定义函数式接口&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">//函数式接口参数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambdaInterfaceDemo</span><span class="hljs-params">(LambdaInterface i)</span>&#123;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用使用一对冒号 <strong>::</strong>  ，通过方法的名字来指向一个方法。方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><ul><li>方法引用主要有四类（仅有一个方法调用的 Lambda 方法体）<ul><li>指向静态方法的方法引用，<code>args -&gt; ClassName.staticMethod(args)</code> 等价 <code>ClassName::staticMethod</code></li><li>指向任意类型的实例方法的方法引用，<code>(arg0, rest) -&gt; arg0.instanceMethod(rest)</code> 等价 <code>ClassName::instanceMethod</code>（arg0 的类型是 ClassName）</li><li>指向现有对象的实例方法的方法引用，<code>args -&gt; expr.instanceMethos(args)</code> 等价 <code>expr::instanceMethod</code></li><li>构造函数引用，<code>ClassName::new</code>（需要有无参构造器）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>      <span class="hljs-type">List</span> <span class="hljs-variable">names</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br> <br>      names.add(<span class="hljs-string">&quot;Tencent&quot;</span>);<br>      names.add(<span class="hljs-string">&quot;Taobao&quot;</span>);<br>      names.add(<span class="hljs-string">&quot;Baidu&quot;</span>);<br>      names.add(<span class="hljs-string">&quot;Bytedance&quot;</span>);<br> <br>      names.forEach(System.out::println);<br>   &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Tencent</span><br><span class="hljs-comment">Taobao</span><br><span class="hljs-comment">Baidu</span><br><span class="hljs-comment">Bytedance</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>函数式接口(Functional Interface)是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<strong>函数式接口可以被隐式转换为 lambda 表达式。</strong></p><p>JDK 1.8 之前已有的函数式接口:</p><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.util.Comparator</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher</li><li>java.lang.reflect.InvocationHandler</li><li>java.beans.PropertyChangeListener</li><li>java.awt.event.ActionListener</li><li>javax.swing.event.ChangeListener</li></ul><p>DK 1.8 新增加的函数接口：</p><ul><li>java.util.function</li></ul><p>定义一个函数式接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GreetingService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayMessage</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-comment">//使用Lambda表达式实现该接口</span><br><span class="hljs-type">GreetingService</span> <span class="hljs-variable">greetService1</span> <span class="hljs-operator">=</span> message -&gt; System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br></code></pre></td></tr></table></figure><h1 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流(Stream)"></a>流(Stream)</h1><ul><li>Java 8 新增了 <code>java.util.stream.Stream</code> 包</li><li>流：从支持<strong>数据处理操作</strong>的<strong>源</strong>生成的<strong>元素序列</strong></li><li>集合是一个内存中的数据结构，包含数据结构中目前所有的值，其主要目的是以特定的时间&#x2F;空间复杂度存储和访问元素，表达计算，它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。</li><li>流并不<strong>存储数据</strong>，也不会<strong>改变源对象</strong>。</li></ul><blockquote><p>流只能遍历一次。它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p><p>流类型：stream 串行流。parallelStream 并行流，可多线程执行。</p></blockquote><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><ul><li><p>通过集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Employee&gt; employees = EmployeeData.getEmployees();<br><br><span class="hljs-comment">//        default Stream&lt;E&gt; stream() : 返回一个顺序流</span><br>        Stream&lt;Employee&gt; stream = employees.stream();<br><br><span class="hljs-comment">//        default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span><br>        Stream&lt;Employee&gt; parallelStream = employees.parallelStream();<br><br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过数组:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>       <span class="hljs-comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span><br>       <span class="hljs-type">IntStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> Arrays.stream(arr);<br><br>       <span class="hljs-type">Employee</span> <span class="hljs-variable">e1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;Tom&quot;</span>);<br>       <span class="hljs-type">Employee</span> <span class="hljs-variable">e2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1002</span>,<span class="hljs-string">&quot;Jerry&quot;</span>);<br>       Employee[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>[]&#123;e1,e2&#125;;<br>       Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="流的用法"><a href="#流的用法" class="headerlink" title="流的用法"></a>流的用法</h2><blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">中间操作（Intermediate <span class="hljs-keyword">Operations</span>）：中间操作会返回一个新的流，一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后会返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。而是在终端操作开始的时候才真正开始执行。<br>最终操作（Terminal <span class="hljs-keyword">Operations</span>）：是指返回最终的结果。一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>stringList.add(<span class="hljs-string">&quot;ddd2&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;aaa2&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;bbb1&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;aaa1&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;bbb3&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;bbb2&quot;</span>);<br>stringList.add(<span class="hljs-string">&quot;ddd1&quot;</span>);<br><span class="hljs-comment">//Filter（筛选）</span><br>stringList<br>                .stream()<br>                .filter((s) -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>))<br>                .forEach(System.out::println);<span class="hljs-comment">//aaa2 aaa1</span><br><span class="hljs-comment">//Stream 提供了新的方法 &#x27;forEach&#x27; 来迭代流中的每个数据</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Sorted(排序)。排序是一个 中间操作，返回的是排序好后的 Stream。如果不指定一个自定义的 Comparator 则会使用默认排序（不会影响原有的数据源）。</span><br><span class="hljs-comment">*/</span><br> stringList<br>                .stream()<br>                .sorted()<br>                .filter((s) -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>))<br>                .forEach(System.out::println);<span class="hljs-comment">// aaa1 aaa2</span><br><span class="hljs-comment">//Map（映射）。中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象</span><br>stringList<br>                .stream()<br>                .map(String::toUpperCase)<br>                .sorted((a, b) -&gt; b.compareTo(a))<br>                .forEach(System.out::println);<br><span class="hljs-comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;BBB1&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Match(匹配)。Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 最终操作 ，并返回一个 boolean 类型的值。</span><br><span class="hljs-comment">*/</span><br><br> <span class="hljs-type">boolean</span> <span class="hljs-variable">anyStartsWithA</span> <span class="hljs-operator">=</span><br>                stringList<br>                        .stream()<br>                        .anyMatch((s) -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>));<br>        System.out.println(anyStartsWithA);      <span class="hljs-comment">// true</span><br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">allStartsWithA</span> <span class="hljs-operator">=</span><br>                stringList<br>                        .stream()<br>                        .allMatch((s) -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>));<br><br>        System.out.println(allStartsWithA);      <span class="hljs-comment">// false</span><br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">noneStartsWithZ</span> <span class="hljs-operator">=</span><br>                stringList<br>                        .stream()<br>                        .noneMatch((s) -&gt; s.startsWith(<span class="hljs-string">&quot;z&quot;</span>));<br><br>        System.out.println(noneStartsWithZ);      <span class="hljs-comment">// true</span><br><span class="hljs-comment">//Count(计数)。Count是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">startsWithB</span> <span class="hljs-operator">=</span><br>                stringList<br>                        .stream()<br>                        .filter((s) -&gt; s.startsWith(<span class="hljs-string">&quot;b&quot;</span>))<br>                        .count();<br>        System.out.println(startsWithB);    <span class="hljs-comment">// 3</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Reduce(规约)。这是一个 最终操作 ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过 Optional 接口表示的：</span><br><span class="hljs-comment">*/</span><br>Optional&lt;String&gt; reduced =<br>                stringList<br>                        .stream()<br>                        .sorted()<br>                        .reduce((s1, s2) -&gt; s1 + <span class="hljs-string">&quot;#&quot;</span> + s2);<br><br>        reduced.ifPresent(System.out::println);<br><span class="hljs-comment">//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</span><br><span class="hljs-comment">//limit(切片)。获取指定数量的流。</span><br>stringList<br>                .stream()<br>                .limit(<span class="hljs-number">2</span>)<br>                .forEach(System.out::println);<span class="hljs-comment">//ddd2 aaa2</span><br><br>stringList<br>                .stream()<br>                .limit(<span class="hljs-number">5</span>)<br>                .forEach(System.out::println);<span class="hljs-comment">//ddd2 aaa2 bbb1 aaa1 bbb3</span><br><br></code></pre></td></tr></table></figure><h2 id="Parallel-Streams-并行流"><a href="#Parallel-Streams-并行流" class="headerlink" title="Parallel Streams(并行流)"></a>Parallel Streams(并行流)</h2><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br>List&lt;String&gt; values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(max);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; max; i++) &#123;<br>    <span class="hljs-type">UUID</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID();<br>    values.add(uuid.toString());<br>&#125;<br><span class="hljs-comment">//串行排序</span><br><span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> values.stream().sorted().count();<br>System.out.println(count);<br><br><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br><br><span class="hljs-type">long</span> <span class="hljs-variable">millis</span> <span class="hljs-operator">=</span> TimeUnit.NANOSECONDS.toMillis(t1 - t0);<br>System.out.println(String.format(<span class="hljs-string">&quot;sequential sort took: %d ms&quot;</span>, millis));<br><br><span class="hljs-comment">//并行排序</span><br><span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> values.parallelStream().sorted().count();<br>        System.out.println(count);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">millis</span> <span class="hljs-operator">=</span> TimeUnit.NANOSECONDS.toMillis(t1 - t0);<br>        System.out.println(String.format(<span class="hljs-string">&quot;parallel sort took: %d ms&quot;</span>, millis));<br><br></code></pre></td></tr></table></figure><h1 id="Date-API-日期时间相关"><a href="#Date-API-日期时间相关" class="headerlink" title="Date API (日期时间相关)"></a>Date API (日期时间相关)</h1><p>Java 8在 <code>java.time</code> 包下包含一个全新的日期和时间API。</p><ul><li><p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 </p></li><li><p>Java 8 新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 获取当前日期</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();<br>today.lengthOfMonth(); <span class="hljs-comment">// today.get(ChronoField.DAY_OF_MONTH);//都是获取当前月份的天数,</span><br><span class="hljs-comment">//前者在 import java.time.LocalDate 包, 后者在 java.time.temporal.ChronoField 包;</span><br><span class="hljs-comment">// 判断是否时闰年</span><br>today.isLeapYear();<br><br><span class="hljs-comment">// 获取当前时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>System.out.println(now); <span class="hljs-comment">//2022-04-01T11:02:32.651552600</span><br><br><span class="hljs-comment">// 设置时间</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<br>System.out.println(dateTime);<span class="hljs-comment">//2022-04-01T11:11:11</span><br><span class="hljs-comment">// 获取年、月、日、时、分、秒</span><br>dateTime.getYear(); <span class="hljs-comment">// dateTime.get(ChronoField.YEAR);</span><br>dateTime.getMonth().getValue(); <span class="hljs-comment">// dateTime.get(ChronoField.MONTH_OF_YEAR);</span><br>dateTime.getDayOfMonth(); <span class="hljs-comment">// dateTime.get(ChronoField.DAY_OF_MONTH);</span><br>dateTime.getHour();<br>dateTime.getMinute();<br>dateTime.getSecond();<br><br><span class="hljs-comment">// 调整日期/时间，返回修改了属性的新对象</span><br>System.out.println(dateTime.withDayOfMonth(<span class="hljs-number">25</span>)); <br><span class="hljs-comment">//也可用 dateTime.with(ChronoField.DAY_OF_MONTH, 25) , 输出 2022-04-25T11:11:11 </span><br><br><span class="hljs-comment">// 当月的最后一天</span><br>dateTime.with(TemporalAdjusters.lastDayOfMonth()); <span class="hljs-comment">//2022-04-30T11:11:11</span><br><br><span class="hljs-comment">// 比较先后</span><br>System.out.println(dateTime.isAfter(now));<span class="hljs-comment">//false</span><br>System.out.println(dateTime.isBefore(now));<span class="hljs-comment">//true</span><br><br><span class="hljs-comment">// 加减时间</span><br>System.out.println(dateTime.plusDays(<span class="hljs-number">1</span>));<span class="hljs-comment">// dateTime.plus(1, ChronoUnit.DAYS);</span><br>System.out.println(dateTime.minusDays(<span class="hljs-number">1</span>));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2022-04-02T11:11:11</span><br><span class="hljs-comment">2022-03-31T11:11:11</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 格式化</span><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(<span class="hljs-string">&#x27;\n&#x27;</span> + formatter.format(now) + <span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-comment">//输出 2022-04-01 11:55:39 , 需导入 java.time.format.DateTimeFormatter 包</span><br><br><span class="hljs-comment">// LocalDateTime 转 String</span><br>formatter.format(now); <span class="hljs-comment">// now.format(formatter);</span><br>System.out.println(formatter.format(now).getClass());<br><span class="hljs-comment">//输出 class java.lang.String</span><br><br><span class="hljs-comment">// String 转 LocalDateTime</span><br>LocalDateTime.parse(<span class="hljs-string">&quot;2022-04-01 23:59:59&quot;</span>, formatter);<br><br><span class="hljs-comment">// LocalDateTime 转 LocalDate、LocalTime</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> dateTime.toLocalDate();<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">localTime</span> <span class="hljs-operator">=</span> dateTime.toLocalTime();<br><br>System.out.println(localDate);<span class="hljs-comment">//2022-04-01</span><br>System.out.println(localTime);<span class="hljs-comment">//11:11:11</span><br><br><span class="hljs-comment">// LocalDate、LocalTime 转 LocalDateTime</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime1</span> <span class="hljs-operator">=</span> localDate.atStartOfDay();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime2</span> <span class="hljs-operator">=</span> LocalDateTime.of(localDate, localTime);<br><br><span class="hljs-comment">// 获取当前时间戳</span><br><span class="hljs-type">long</span> <span class="hljs-variable">millisecond</span> <span class="hljs-operator">=</span> Instant.now().toEpochMilli(); <br><span class="hljs-comment">// 自1970-01-01T00：00：00Z 时代以来的毫秒数, 转换当前时间的毫秒值</span><br><span class="hljs-type">long</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> Instant.now().getEpochSecond();<br><span class="hljs-comment">// 返回 1970-01-01T00：00：00Z 时代的秒数。</span><br>Instant.ofEpochMilli(millisecond); <span class="hljs-comment">// 2022-04-01T07:55:23.808Z 毫秒值转 Instant。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    测试时，发现 Instant.now() 返回的时间戳与北京时间相差8小时。考虑调用的是jvm时间，而jvm使用的时间默认是 0 时区的时间，但以 TimeZone.setDefault(TimeZone.getTimeZone(&quot;GMT+8&quot;)) 测试后，通过输出new Date（）发现jvm时间已改变，但 Instant.now() 返回的时间仍然相差 8 小时。</span><br><span class="hljs-comment">    阅读源码发现, Instant.now() 使用的是 Clock.systemUTC().instant() 即 UTC 时间, 正好与北京时间相差 8 小时(找了些资料才知道，末尾的 Z 表示这是一个世界标准时间, 即UTC)。解决方法：通过 Instant.now().plusMillis(TimeUnit.HOURS.toMillis(8)) 加上8小时。或 Instant.now().atZone(ZoneId.systemDefault()) 使用当前时区（这里返回的值是 ZonedDateTime 类型)。</span><br><span class="hljs-comment">    小结：Instant.now() 适用于需要获取不带日期或时间的当前时刻</span><br><span class="hljs-comment">    */</span><br><br><span class="hljs-comment">// 将日期转换为从 1970-01-01 开始的天数</span><br>System.out.println(today.toEpochDay() + <span class="hljs-string">&quot; 天&quot;</span>);<span class="hljs-comment">//19083 天。 </span><br><br><span class="hljs-comment">// 将此日期时间转换为从 1970-01-01T00：00：00Z 开始的秒数</span><br>dateTime.toInstant(ZoneOffset.of(<span class="hljs-string">&quot;+8&quot;</span>)).toEpochMilli();<span class="hljs-comment">//1648782671000</span><br><br><span class="hljs-comment">// LocalDateTime 转换为 ZonedDateTime，再转换为 Instant，再转换为 Date</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());<br><span class="hljs-comment">// Date 转换为 Instant，再转换为 LocalDateTime</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());<br><br><span class="hljs-comment">/* // 获取相差时间间隔</span><br><span class="hljs-comment">amount = start.until(end, ChronoUnit.DAYS); // end.toEpochDay() - start.toEpochDay()</span><br><span class="hljs-comment">amount = ChronoUnit.DAYS.between(start, end);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 时间长度：Duration、Period</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">1970</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2022</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Period</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Period.between(localDate1, localDate2);<br>        System.out.println(<span class="hljs-string">&quot;years:&quot;</span>+p.getYears()+<span class="hljs-string">&quot; months:&quot;</span>+p.getMonths()+<span class="hljs-string">&quot; days:&quot;</span>+p.getDays());<span class="hljs-comment">//years:52 months:3 days:0</span><br><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime1</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">1970</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime2</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>, <span class="hljs-number">04</span>);<br>        <span class="hljs-type">Duration</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Duration.between(localDateTime1, localDateTime2);<br>        System.out.println(<span class="hljs-string">&quot;days:&quot;</span>+d.toDays());<br>        System.out.println(<span class="hljs-string">&quot;hours:&quot;</span>+d.toHours());<br>        System.out.println(<span class="hljs-string">&quot;minutes:&quot;</span>+d.toMinutes());<br>        System.out.println(<span class="hljs-string">&quot;millis:&quot;</span>+d.toMillis());<br><span class="hljs-comment">//days:19083 hours:458014 minutes:27480844 millis:1648850640000</span><br><span class="hljs-comment">//Period只能返回年数，月数，天数；Duration可以返回天数，小时数，分钟数，毫秒数等。</span><br><br><br><span class="hljs-comment">//时区 ID</span><br><span class="hljs-comment">//ZoneId zoneId = ZoneId.systemDefault();//系统默认时区。Asia/Shanghai</span><br><span class="hljs-comment">//ZoneId zoneId = TimeZone.getDefault().toZoneId();//Asia/Shanghai</span><br><span class="hljs-comment">//ZoneId romeZone = ZoneId.of(&quot;Asia/Shanghai&quot;);//Asia/Shanghai</span><br><br><span class="hljs-comment">//zoneId.getId(); // 时区 ID：Asia/Shanghai</span><br><span class="hljs-comment">//zoneId.getRules(); // 时区规则：ZoneRules[currentStandardOffset=+08:00]</span><br><br><span class="hljs-type">ZoneId</span> <span class="hljs-variable">zoneId</span> <span class="hljs-operator">=</span> ZoneId.of(<span class="hljs-string">&quot;UTC+8&quot;</span>);<br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zonedDateTime</span> <span class="hljs-operator">=</span> ZonedDateTime.of(<span class="hljs-number">2022</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>, <span class="hljs-number">1234</span>, zoneId);<br>System.out.println(zoneId);<span class="hljs-comment">//UTC+08:00</span><br>System.out.println(zonedDateTime);<span class="hljs-comment">//2022-04-01T23:59:59.000001234+08:00[UTC+08:00]</span><br><br><span class="hljs-comment">// 为时间点添加时区信息</span><br>        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zdt1</span> <span class="hljs-operator">=</span> localDate.atStartOfDay(zoneId); <span class="hljs-comment">// 时间为 00:00:00。2022-04-01T00:00+08:00[UTC+08:00]</span><br>        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zdt2</span> <span class="hljs-operator">=</span> dateTime.atZone(zoneId);<span class="hljs-comment">//2022-04-01T11:11:11+08:00[UTC+08:00]</span><br>        <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zdt3</span> <span class="hljs-operator">=</span> Instant.now().atZone(zoneId);<span class="hljs-comment">//2022-04-01T11:11:11+08:00[UTC+08:00]</span><br></code></pre></td></tr></table></figure><p>​</p></li></ul><h1 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations(注解)"></a>Annotations(注解)</h1><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><ul><li>从 Java 8 开始，注解已经能应用于任何类型，包括 new 操作符、类型转换、instanceof 检查、泛型类型参数，以及 implements 和 throws 子句</li></ul><h2 id="多重注解（重复注解）"><a href="#多重注解（重复注解）" class="headerlink" title="多重注解（重复注解）"></a>多重注解（重复注解）</h2><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下 <code>@Repeatable</code> 即可。</p><p>定义一个包装类Hints注解用来放置一组具体的Hint注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> Hints &#123;<br>    Hint[] value();<br>&#125;<br><span class="hljs-meta">@Repeatable(Hints.class)</span><br><span class="hljs-meta">@interface</span> Hint &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例 1: 使用包装类当容器来存多个注解（老方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>例 2：使用多重注解（新方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Hint(&quot;hint1&quot;)</span><br><span class="hljs-meta">@Hint(&quot;hint2&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程</title>
    <link href="/2022/03/27/Java%E5%9F%BA%E7%A1%80-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/03/27/Java%E5%9F%BA%E7%A1%80-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p>**进程 **是程序的一次执行过程，是 <strong>系统运行程序</strong> 的 <strong>基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的 <strong>线程 <strong>就是这个进程中的一个线程，也称</strong>主线程</strong>。</p><p><strong>线程</strong> 是 <em><strong>进程</strong></em> 中执行运算的最小单位，亦即执行处理机调度的基本单位。线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的 <strong>堆</strong> 和 **方法区 **资源，但每个线程有自己的 **程序计数器 (PC) <strong>、</strong>虚拟机栈 **和 <strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><blockquote><p>一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p><blockquote><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p></blockquote></blockquote><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程有若干种状态，如：</p><ul><li>运行状态：线程正在 CPU 上执行程序，此状态可以变为阻塞状态，就绪状态，终止状态</li><li>阻塞状态：线程正在等待某个事件的发生。如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。</li><li>就绪状态：当线程具备运行条件（如，线程对象调用了 start() 方法），该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</li><li>终止状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态，它占用的寄存器和栈等资源将被系统回收，重新分配给别的线程。</li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Java 提供了三种创建线程的方法：</p><h3 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h3><p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义 Runnable 接口的实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// 重写 Runnable 接口中的 run() 方法，线程执行体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                <br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(); <span class="hljs-comment">// 创建 Runnable 实现类的对象 target</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target, <span class="hljs-string">&quot;线程名&quot;</span>); <span class="hljs-comment">// 将 target 作为运行目标来创建创建 Thread 类的对象</span><br>        t.start(); <span class="hljs-comment">// 调用线程对象的 start() 方法来启动该线程</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用匿名内部类的方式创建</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><blockquote><p>run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p></blockquote><h3 id="继承Thread创建线程"><a href="#继承Thread创建线程" class="headerlink" title="继承Thread创建线程"></a>继承Thread创建线程</h3><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p><p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p><p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p><blockquote><p><strong>使用继承 Thread 类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义 Thread 类的子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 重写 Thread 类中的 run() 方法，线程执行体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;                <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(); <span class="hljs-comment">// 创建 Thread 子类的对象</span><br>        t.start(); <span class="hljs-comment">// 调用线程对象的 start() 方法来启动该线程</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用匿名内部类的方式创建</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;.start();<br></code></pre></td></tr></table></figure><p>Thread类的一些重要 <strong>方法</strong>：</p><table><thead><tr><th align="center">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td></tr><tr><td align="center">2</td><td align="left"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td></tr><tr><td align="center">3</td><td align="left"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td></tr><tr><td align="center">4</td><td align="left"><strong>public final void setPriority(int priority)</strong> 更改线程的优先级。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</td></tr><tr><td align="center">5</td><td align="left"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td></tr><tr><td align="center">6</td><td align="left"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td></tr><tr><td align="center">7</td><td align="left"><strong>public void interrupt()</strong> 中断线程。</td></tr><tr><td align="center">8</td><td align="left"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td></tr></tbody></table><h3 id="Callable-和-FutureTask-创建线程"><a href="#Callable-和-FutureTask-创建线程" class="headerlink" title="Callable 和 FutureTask 创建线程"></a>Callable 和 FutureTask 创建线程</h3><p><strong>Callable<V> 接口</strong></p><ul><li>Callable 接口支持泛型，且提供了一个 call() 方法（可以有返回值，可以声明抛出异常）可以作为<strong>线程执行体</strong>，Callable 接口里的泛型形参类型与 call() 方法返回值类型相同。</li><li>call() 可以抛出异常，被外面的操作捕获，获取异常的信息。</li></ul><p><strong>Future<V> 接口</strong></p><ul><li>Future 接口代表 Callable 接口里 call() 方法的返回值，表示异步计算的结果</li></ul><p><strong>FutureTask<V> 类</strong></p><ul><li>FutureTask 实现类<strong>实现</strong>了 RunnableFuture 接口（RunnableFuture 接口继承了 <strong>Runnable 接口和Future</strong> 接口）</li><li>构造器：FutureTask(Callable callable)、FutureTask(Runnable runnable, V result)（指定成功完成时 get 返回给定的结果为 result）</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//1.创建一个实现Callable的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">Callable</span>&#123;<br>    <span class="hljs-comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span><br>    @Override<br>    <span class="hljs-keyword">public</span> Object call() throws Exception &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(i);<br>                <span class="hljs-keyword">sum</span> += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadNew</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">//3.创建Callable接口实现类的对象</span><br>        NumThread numThread = <span class="hljs-keyword">new</span> NumThread();<br>        <span class="hljs-comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numThread);<br>        <span class="hljs-comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//6.获取Callable中call方法的返回值</span><br>            <span class="hljs-comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span><br>            Object <span class="hljs-keyword">sum</span> = futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为：&quot;</span> + <span class="hljs-keyword">sum</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建线程的三种方式对比"><a href="#创建线程的三种方式对比" class="headerlink" title="创建线程的三种方式对比"></a>创建线程的三种方式对比</h3><ul><li><p>继承 Thread 类</p><ul><li>线程类已经继承了 Thread 类，不能再继承其它父类</li><li>如果需要访问当前线程，直接使用 this 即可获得当前线程</li><li>多个线程之间<strong>无法共享线程类中的实例变量</strong></li></ul></li><li><p>实现 Runnable、Callable 接口的方式创建多线程</p><ul><li>线程类只是实现了 Runnable 接口，还可以继承其它类</li><li>如果需要访问当前线程，则必须使用 Thread. currentThread() 方法</li><li>所创建的 Runnable 对象只是<strong>线程的 target</strong>，而多个线程<strong>可以共享同一个 target 对象的实例变量</strong>，所以适合多个相同线程来处理同一份资源的情况。</li></ul></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>多线程之间调用同一对象时，为了运行的安全和准确性，需要对该对象进行同步，确保每一个线程用到的时候该对象的结果都是正确的。</p><ul><li><strong>只需要</strong>对那些<strong>会改变共享资源的、不可被中断的操作</strong>进行同步即可</li><li>保证在任一时刻只有一个线程可以进入修改共享资源的代码区，其它线程只能在该共享资源对象的<strong>锁池</strong>中等待获取锁</li><li>在 Java 中，每一个对象都拥有一个锁标记（monitor），也称为监视器</li><li>线程开始执行同步代码块或同步方法之前，必须先获得对同步监视器的锁定才能进入同步代码块或者同步方法进行操作</li></ul><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><ul><li>语法格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">synchronized关键词可以修饰对象、方法。修饰之后多个线程同时调用一个同步的代码块或者方法时，在任何时刻只能够一个线程能够获得该同步监视的对象锁，执行完代码之后才会释放该锁，在此期间其他调用的线程只能等待该锁被释放后才能调用（在sleep、进行IO操作的时候也不会释放线程锁）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">synchronized</span>(同步监视器对象) &#123; <br>     <span class="hljs-comment">// 需要同步的代码</span><br> &#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>synchronized</code> 关键字来修饰某个方法，就相当于<strong>给调用该方法的对象</strong>加了锁</li><li>对于实例方法，同步方法的同步监视器是 this，即<strong>调用该方法的对象</strong></li><li>对于类方法，同步方法的同步监视器是当前方法<strong>所在类的字节码对象</strong>（如 ArrayUtil.class）</li><li>不要使用 <code>synchronized</code> 修饰 run() 方法，而是把需要同步的操作定义在一个<strong>新的同步方法</strong>中，再在 run() 方法中调用该方法</li></ul><h3 id="Lock-同步锁"><a href="#Lock-同步锁" class="headerlink" title="Lock(同步锁)"></a>Lock(同步锁)</h3><ul><li>java.util.concurrent.locks 包中，Lock 替代了 synchronized 方法和语句的使用</li><li>Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁。（在sleep、进行IO操作的时候可以释放线程锁）</li><li>常用的实现类ReentrantLock（可重入锁）：java.util.concurrent.locks 包中，通常建议<strong>使用 finally 块来确保在必要时释放锁</strong>ReentrantLock 是可重入锁：<strong>当前持有该锁的线程能够多次获取该锁</strong>，无需等待（可以在递归算法中使用锁）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 吃了编号为 &quot;</span> + num-- + <span class="hljs-string">&quot; 的苹果&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized和Lock对比"><a href="#synchronized和Lock对比" class="headerlink" title="synchronized和Lock对比"></a>synchronized和Lock对比</h3><ul><li><p>Lock 是一个接口，而 synchronized 是 Java 中的关键字。</p></li><li><p>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁</p></li><li><p>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会直等待下去，不能够响应中断</p></li><li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到</p></li><li><p>Lock 可以提高多个线程进行读操作的效率</p></li><li><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竟争），此时 Lock 的性能要远远优于 synchronized。所以说，在具体使用时要根据适当情况选择</p></li></ul><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>Java 的线程间通过<strong>共享内存</strong>的方式进行通信。线程通信涉及到 Object 类中的三个方法：</p><ol><li>wait(): 一旦执行此方法，JVM 把该线程存放到<strong>等待池</strong>中，当前线程进入阻塞状态，等待其他的线程唤醒该线程，并释放同步监视器。</li><li>notify(): 执行此方法，会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</li><li>notifyAll(): 执行此方法，会唤醒所有被wait的线程。</li></ol><blockquote><p>这些方法必须在同步块中使用，且只能被<strong>同步监视器对象</strong>来调用，否则会引发 IllegalMonitorStateException 异常</p><blockquote><p>sleep() 和 wait() 的异同:  </p><blockquote><p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p><p>不同点：</p><ol><li>两个方法声明的位置不同：Thread 类中声明 sleep() , Object 类中声明 wait()</li><li>sleep()可以在任何需要的场景下调用。 wait() 必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li></ol></blockquote></blockquote></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>**死锁 **是指，在一个进程集合中，每个进程都在 <strong>等待</strong> 仅由该集合中的 <strong>其他进程</strong> 才能引发的事件而无限期地 <strong>僵持</strong> 下去的局面。</p><ul><li>当两个线程相互等待对方释放同步监视器时就会发生死锁，死锁无法解决，只能避免</li><li>一旦出现死锁，所有线程处于阻塞状态，程序无法继续向下执行</li><li>避免死锁<ul><li>加锁顺序：所有的线程都以同样的顺序加锁和释放锁</li><li>加锁时限：线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁</li></ul></li><li>定位死锁：利用 jstack 等工具获取线程栈，然后定位相互之间的依赖关系，进而找到死锁</li></ul><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h3><ul><li>让执行的线程暂停一段时间，进入阻塞状态</li></ul><h3 id="联合线程"><a href="#联合线程" class="headerlink" title="联合线程"></a>联合线程</h3><ul><li>让当前线程等待另一个线程完成，而当前线程进入阻塞状态</li></ul><h3 id="后台线程-x2F-守护线程（Daemon-Thread）"><a href="#后台线程-x2F-守护线程（Daemon-Thread）" class="headerlink" title="后台线程 &#x2F; 守护线程（Daemon Thread）"></a>后台线程 &#x2F; 守护线程（Daemon Thread）</h3><ul><li>后台线程 &#x2F; 守护线程 &#x2F; 精灵线程（Daemon Thread）</li><li>在后台运行，为其它线程提供服务的线程，如 垃圾回收线程</li><li>特征：如果所有的前台线程都死亡，后台线程会自动死亡</li><li>前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程</li></ul><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul><li>优先级的高低只和线程获得执行机会的次数多少有关</li><li>每个线程默认的优先级都与创建它的父线程的优先级相同</li><li>int 类型的静态常量：MAX_PRIORITY、MIN_PRIORITY、NORM_PRIORITY，值分别是10（最高优先级）、1（最低优先级）、5（默认优先级）</li></ul><h3 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h3><ul><li>让执行的线程暂停，进入就绪状态</li><li>当某个线程调用了 yield() 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 泛型、反射、注解、异常</title>
    <link href="/2022/03/26/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/03/26/Java%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><blockquote><p>一般的类和方法，只能使用具体的类型：基本类型或自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制会极大的束缚代码。</p></blockquote><p> 泛型实现了“<strong>参数化类型</strong>的概念”。泛型这个术语的意思是：“适用于许多许多的类型”。泛型旨在编写更通用的代码，要使代码能应用于“某种不具体的类型，而不是一个具体的接口或类。在代码中表现为允许在定义类、接口时通过一个<strong>标识</strong>表示类中某个属性的<strong>类型</strong>或者是某个方法的<strong>返回值</strong>及<strong>参数类型</strong>。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时确定（即传入实际的类型参数，也称为类型实参）。</p><p>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-comment">//静态方法中不能使用类的泛型(编译不会通过),但是泛型方法可以声明为静态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//实现泛型接口，指定类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(E[] inputArray)</span> &#123;<br>    <span class="hljs-keyword">for</span> (E element : inputArray) &#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s &quot;</span>, element);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h2><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><p>Object是所有类的根类，任何类的对象都可以设置给Object引用变量，使用的时候可能需要进行<strong>类型强制转换</strong>，但是用了泛型T、E这类标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换</p><h3 id="限定通配符与非限定通配符"><a href="#限定通配符与非限定通配符" class="headerlink" title="限定通配符与非限定通配符"></a>限定通配符与非限定通配符</h3><p>限定通配符对类型进行限制，泛型中有两种限定通配符：</p><ol><li>表示类型的上界，格式为&lt;? extends T&gt;，表示类型必须为T类型或者T子类</li><li>表示类型的下界，格式为&lt;? super T&gt;，表示类型必须为T类型或T类型的父类。</li></ol><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的<strong>内部属性及方法</strong>。反射被称为框架的灵魂，<strong>框架 &#x3D; 反射 + 注解 + 设计模式</strong>。通过反射机制，程序可以知道：</p><ul><li><p>任意一个类的所有属性和方法。</p></li><li><p>任意一个对象的一个属性和方法</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>IDE的自动提示功能</strong>，如：输入对象，提示其属性和方法。此时，IDE会通过反射，获取类和对象的具体信息。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p><code>Class</code>类是反射实现的基础。在程序运行期间，JVM 始终为所有的对象维护一个被称为<strong>运行时的类型标识</strong>，这个信息跟踪着每个对象所属的类的完整结构信息，包括包名、类名、实现的接口、拥有的方法和字段等。可以通过专门的 Java 类访问这些信息，这个类就是 <code>Class</code> 类。我们可以把 <code>Class</code> 类理解为<strong>类的类型</strong>，一个 <code>Class</code> 对象，称为类的类型对象，<strong>一个</strong> <strong><code>Class</code></strong> <strong>对象对应一个加载到 JVM 中的一个</strong> <strong><code>.class</code></strong> <strong>文件</strong>。也就是说，在Java中，<strong>类也是对象</strong>，类是java.lang.Class类的实例对象，这个对象称为类的类类型（class type)。反射在读取一个类之前，必须获取到java.lang.Class对象。Class对象包含类的所有信息，通过Class对象的方法，可以获取到<strong>构造方法，成员变量，成员方法和接口</strong>等信息。获取方法有：</p><ul><li>字面量直接获取：对象名.class。这种方式不会触发类的初始化但会将类加载到方法区。</li><li>Object类的getClass方法，例如Object.getClass()。这种方式会触发类的初始化。</li><li>Class的静态方法。如：Class.forName()。这也会触发类的初始化。</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p><strong>Field</strong></p><p>成员变量，类中的属性对象。通过Class类的getDeclaredField() （获取方法）或getDeclaredFields() （获取所有方法，包括私有方法）方法获取。</p><p><strong>Class类的基本API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-number">1.</span> Class.getName()可以获取类的名称<br><span class="hljs-number">2.</span> Class.getSimpleName();<span class="hljs-comment">//不包含包名的类的名称</span><br><span class="hljs-number">3.</span> Class.getMethods()获取类的【<span class="hljs-keyword">public</span>方法】集合，【包括继承来的】<br><span class="hljs-number">4.</span> Class.getDeclaredMethods()获取的是所有该类【自己声明】的方法，【不问访问权限】<br></code></pre></td></tr></table></figure><p><strong>Method</strong></p><p>类中的方法对象。包括了静态方法和成员方法（包括抽象方法在内）。通过invoke()来完成方法被动态调用的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> m.getReturnType()得到该方法的返回值类型的类类型（class），如<span class="hljs-type">int</span>.<span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>.class<br><span class="hljs-number">2.</span> m.getName()得到方法的名称<br><span class="hljs-number">3.</span> m.getParameterTypes()获得参数列表类型的类类型，如参数为(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)则得到(<span class="hljs-type">int</span>.class ,<span class="hljs-type">int</span> class)<br></code></pre></td></tr></table></figure><p><strong>getDeclaredMethod</strong></p><p>可以获取指定方法名和参数的方法对象 Method(对象，参数列表)。</p><p><strong>privateGetDeclaredMethods</strong></p><p>从缓存或JVM中获取该Class中申明的方法列表。</p><p><strong>searchMethods</strong></p><p>从返回的方法列表里找到一个匹配名称和参数的方法对象。如果找到一个匹配的Method，则重新copy一份返回，即Method.copy()方法。</p><p><strong>ReflectionData</strong></p><p>用来缓存从JVM中读取类的如下属性数据。</p><p><strong>Constructor</strong></p><p>构造函数。类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、通过Class.getConstructor()获得Constructor[]所有公有构造方法信息<br><span class="hljs-number">2</span>、建议getDeclaredConstructors()获取自己声明的构造方法<br><span class="hljs-number">3</span>、Constructor.getName():String<br><span class="hljs-number">4</span>、Constructor.getParameterTypes():Class[]<br></code></pre></td></tr></table></figure><h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h1><blockquote><ul><li>从 Java 5 开始出现</li><li>Annotaticm 能被用来为程序元素（ 类、方法、成员变量等）设置元数据</li><li>所有注解都隐式继承了 Annotation java.lang.annotation.Annotation 接口</li></ul></blockquote><p>注解可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，本质上是一个继承了<code>Annotation</code> 的特殊接口。</p><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><ul><li>在 java.lang 包下</li><li><code>@Override</code> 限定重写父类方法</li><li><code>@Deprecated</code> 标示已过时（与文档注释中的 @deprecated 标记的作用基本相同），其他程序使用已过时的类、方法时，编译器会发出警告</li><li><code>@SuppressWarnings(&quot;变量值&quot;)</code> 抑制编译器警告（常见的变量值：unused, rawtypes, unchecked, serial, deprecation, all）</li><li><code>@SafeVarargs</code> 抑制编译器“堆污染”警告（Java 7 新增）</li><li><code>@FunctionalInterface</code> 函数式接口（接口中只有一个抽象方法）（Java 8 新增）</li></ul><h2 id="JDK-的元注解"><a href="#JDK-的元注解" class="headerlink" title="JDK 的元注解"></a>JDK 的元注解</h2><ul><li>在 java.lang.annotation 包下，用于修饰其它的 Annotation 定义</li><li><code>@Target</code>：用于指定被修饰的注解能用于修饰哪些程序元素常量值封装在 ElementType 枚举类中：TYPE、FIELD、CONSTRUCTOR、METHOD、LOCAL_VARIABLE、PACKAGE、PARAMETER、ANNOTATION_TYPE</li><li><code>@Retention</code>：用于指定被修饰的注解可以保留多长时间常量值封装在 RetentionPolicy 枚举类中：SOURCE、CLASS（默认值）、RUNTIME。此修饰可以通过反射提取</li><li><code>@Documented</code>：其修饰的注解会保存到 API 文档中</li><li><code>@Inherited</code>：其修饰的注解可以被子类所继承</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li><p>Annotation 中的属性以<strong>无参数的抽象方法</strong>的形式来定义</p></li><li><p>属性的类型只能是基本类型、String、Class、annotation、枚举及这些类型一维数组</p></li><li><p>在定义 Annotation 的属性时可以使用 <code>default</code> 为其指定默认值</p></li><li><p>使用带属性的注解时，必须为该注解的所有没有默认值的属性指定值</p></li><li><p>对于 Annotation 中<strong>变量名为 value</strong>属性，在使用该注解时可以直接在该注解后的括号里指定 value 属性的值，无须使用“value &#x3D; 变量值”的形式</p></li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><blockquote><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11&#x2F;0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p></blockquote><p>异常发生的原因有很多，通常包含以下几大类：</p><ul><li>用户输入了非法数据。</li><li>要打开的文件不存在。</li><li>网络通信时连接中断，或者JVM内存溢出。</li></ul><p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</p><h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>在Java中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable</strong> <strong>类</strong>。Throwable 类有两个重要的子类:</p><ul><li><p>Exception：程序本身可以处理的异常，可以通过catch来进行捕获。Exception又可以分为Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p></li><li><p>Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p></li></ul><blockquote><h3 id="Checked-Exception-和-Unchecked-Exception的区别："><a href="#Checked-Exception-和-Unchecked-Exception的区别：" class="headerlink" title="Checked Exception 和 Unchecked Exception的区别："></a>Checked Exception 和 Unchecked Exception的区别：</h3><p>​    一般情况下，Java 代码在编译过程中，如果受检查异常没有被  <code> catch/throw</code>  处理的话，就没办法通过编译 。除了    <code>RuntimeException(运行时异常)</code> 及其子类（<code>NullPointerException、NumberFormatException、ArrayIndexOutOfBoundsException</code>…）以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p></blockquote><p>以及重要的实例方法：</p><ul><li><code>String getMessage()</code>：返回该异常的描述信息（提示给用户）</li><li><code>String toString()</code>：返回该异常的类型和描述信息</li><li><code>void printStackTrace()</code>：打印异常的跟踪栈信息到控制台，包括异常的类型、异常的原因、异常出现的位置（开发和调试）</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。</p><p>不管 try 块中的代码是否出现异常，也不管哪一个 catch 块被执行，甚至在 try 块或 catch 块中执行了 return 语句，<strong>finally 块总会被执行</strong>（除非在 try 块或会执行的 catch 块中调用退出 JVM 的相关方法）。</p><p>try 块必须和 catch 块或和 finally 块同在，<strong>不能单独存在</strong>，catch 块或和 finally 块二者<strong>必须出现一个</strong>，finally 块必须位于所有的 catch 块之后。</p><blockquote><p>当程序执行 try 块、catch 块时遇到 <strong>return 或 throw 语句</strong>时，系统<strong>不会立即结束该方法</strong>，而是去寻找该异常处理流程中是否包含 finally 块，如果有 finally 块，系统<strong>立即开始执行 finally 块</strong>——只有当 finally 块执行完成后，系统才会再次跳回来执行 try 块、catch 块里的 return 或 throw 语句；如果 finally 块里也使用了 <strong>return 或 throw 等导致方法终止的语句</strong>，finally 块已经终止了方法，系统将<strong>不会跳回去</strong>执行 try 块、catch 块里的任何代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 异常的变量名<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 异常的变量名<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>  <span class="hljs-comment">// 关闭资源对象、流对象等</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-throws-声明抛出异常"><a href="#使用-throws-声明抛出异常" class="headerlink" title="使用 throws 声明抛出异常"></a>使用 throws 声明抛出异常</h2><p>在可能出现异常的方法上<strong>声明</strong>可能抛出的异常类型，用于表示当前方法不处理异常，而是<strong>提醒</strong>该方法的调用者来处理异常，因为throws不具有处理异常的功能。</p><ul><li><p>当前方法使用 throws 声明抛出异常，该异常将交给上一级调用者处理，调用者要么 try … catch，要么也 throws</p></li><li><p>如果 main 方法也使用 throws 声明抛出异常，该异常将交给 JVM 处理，JVM 对异常的处理方法是，打印异常的跟踪栈信息，并中止程序运行</p></li><li><p>子类方法声明抛出的异常类和父类方法声明抛出的异常类<strong>相同或者是其子类</strong>（运行时异常除外）</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMath</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>             <span class="hljs-keyword">return</span> x/y;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用-throw-自行抛出异常"><a href="#使用-throw-自行抛出异常" class="headerlink" title="使用 throw 自行抛出异常"></a>使用 throw 自行抛出异常</h2><p>throw 语句可以单独使用，但throw 后面只能跟一个<strong>异常对象</strong> 。在有返回值的方法中，可以使用 throw <strong>来避免返回一个空值</strong></p><ul><li>如果 throw 语句抛出的异常是 Checked 异常，则该 throw 语句必须处于 try 块里，或处于带 throws 声明的方法中</li><li>如果 throw 语句抛出的异常是 Runtime 异常，则该语句无须放在 try 块里，也无须放在带 throws 声明抛出的方法中</li><li>在 catch 块中使用 throw 语句，方法既可以捕获异常，还可以抛出异常给方法的调用者</li></ul><p>语法格式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ExceptionClass</span>(<span class="hljs-string">&quot;异常信息&quot;</span>);<span class="hljs-comment">//终止方法</span><br></code></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul><li><p>自定义 Checked 异常，应继承 Exception</p></li><li><p>自定义 Runtime 异常，应继承 RuntimeException</p></li><li><p>所有异常都必须是 Throwable 的子类。</p><p>可以像下面这样定义自己的异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li><p>只继承Exception 类来创建的异常类是检查性异常类。</p></li><li><p>一个异常类和其它任何类一样，包含有变量和方法。</p></li></ol></blockquote></li></ul><h2 id="异常处理规则"><a href="#异常处理规则" class="headerlink" title="异常处理规则"></a>异常处理规则</h2><ul><li>不要过度使用异常：<ul><li>对于完全已知的错误，应该编写处理这种错误的代码，增加程序的健壮性</li><li>对外部的、不能确定和预知的运行时错误才使用异常</li></ul></li><li>不要使用过于庞大的 try 块</li><li>避免使用 Catch All 语句</li><li>不要忽略捕获到的异常</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 - 队列</title>
    <link href="/2022/03/24/Java%E5%9F%BA%E7%A1%80-%E9%98%9F%E5%88%97/"/>
    <url>/2022/03/24/Java%E5%9F%BA%E7%A1%80-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong><u>队列</u></strong> 是 先进先出( FIFO，First In, First Out) 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。</p><ul><li><p><strong>队列的操作在两端进行，在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p></li><li><p>在队列中，删除的数据还 <strong>保留</strong> 在内存中，但头指针已不再指向它</p></li><li><p>队列和栈一样，存在上溢和下溢。此外，还存在”<strong>假溢出</strong>“现象</p></li></ul><h1 id="队列的分类"><a href="#队列的分类" class="headerlink" title="队列的分类"></a>队列的分类</h1><blockquote><p>为了方便起见，约定：初始化建空队时，令front&#x3D;rear&#x3D;0,当队空时：</p><p>front&#x3D;rear</p><p>当队满时：front&#x3D;rear 亦成立</p></blockquote><h2 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h2><p>单队列又分为<strong>顺序队列</strong>(数组实现)和<strong>链式队列</strong>(链表实现)。单队列从前面删除元素，从后面插入元素，类似于现实中的排队（只是不允许插队🤣）。</p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p> 队列的顺序存储结构，又称为顺序队列，顺序队列实际上是运算受限的顺序表。</p><p>在顺序队列，由于数组分配的存储空间存在边界，头尾指针不断增加而不减小（或只减小而不增加），被删除元素的存储空间不能重新利用，会发生”假溢出“，即明明有位置却不能添加元素。</p><blockquote><p>解决假溢出的方法有许多种，如：设定队首指针不动，只要插入元素，在队列的末尾直接插入；只要删除元素，从队首的位置直接删除就行了，但这样会造成大量的数据元素移动。一种更好的办法是，将队列循环起来，也就是循环队列。</p></blockquote><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>链式队列，使用带头指针front和尾指针rear的单链表实现。一般用<strong>单向链表</strong>来实现，不采用循环双链表或者双链表主要是双链表的空间开销（空间复杂度，多前继指针）相对单链表来说大了不少，而单链表只要新增头指针和尾指针就可以轻松实现常数时间内（时间复杂度为O(1)）访问头尾结点。</p><p>Java实现链式队列的其中一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkqueue</span>&#123;<br>    <span class="hljs-keyword">private</span> link front;<br>    <span class="hljs-keyword">private</span> link rear;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">linkqueue</span><span class="hljs-params">()</span>&#123;<br>        setup();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">linkqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> sz)</span>&#123;<br>        setup();<br>    &#125;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span>&#123;<br>        rear=<span class="hljs-literal">null</span>;<br>        front=rear;<br>    &#125;<br>    <span class="hljs-comment">//清空队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>&#123;<br>        rear=<span class="hljs-literal">null</span>;<br>        front=rear<br>    &#125;<br>    <span class="hljs-comment">//插入元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(object it)</span>&#123;<br>        <span class="hljs-keyword">if</span>(rear!=<span class="hljs-literal">null</span>)&#123;<br>            rear.setNext(<span class="hljs-keyword">new</span> <span class="hljs-title class_">link</span>(it,<span class="hljs-literal">null</span>));<br>            rear=rear.next();<br>        &#125;<br>        <span class="hljs-keyword">else</span> front=rear=<span class="hljs-keyword">new</span> <span class="hljs-title class_">link</span>(it,<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">//删除元素</span><br>    <span class="hljs-keyword">public</span> object <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">assert</span>.notfalse(!isempty());<br>        <span class="hljs-type">object</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> front.element();<br>        front = front.next();<br>        <span class="hljs-keyword">if</span>(front==<span class="hljs-literal">null</span>)<br>            tear=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> it;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，令rear指向front，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。但是，在顺序队列中，front&#x3D;&#x3D;rear即表示队列为空，在循环队列则不然，由于头尾相接，队列为满时，也会体现为front&#x3D;&#x3D;rear。这里有两种解决方法：</p><ol><li>可以一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并<code>flag=1</code> 的时候队列为满。</li><li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li></ol><p>循环队列入队时：rear&#x3D;(rear+1)%maxsize，出队时: front&#x3D;(front+1)%maxsize</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列是一个两端都是结尾的队列。队列的每一端都可以插入数据项和移除数据项。这些方法可以叫做insertLeft()和insertRight()，以及removeLeft()和removeRight()。</p><p>如果禁止调用insertLeft()和removeLeft()方法（或禁用右端操作），双端队列的功能就和栈一样。</p><p>如果禁止调用insertLeft()和removeRight()方法（或相反的一对方法），它的功能就和单队列一样了。</p><p>在容器类库中有时会用双端队列来提供栈和队列两种功能。由于不太常用，这里偷个懒，不深入研究了。</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列是比栈和队列更专用的数据结构，但它在很多情况下都很有用。像普通队列一样 ，优先级队列有一个队头和一个队尾，并且也是从队头移除数据项。不过在优先级队列中，数据项按<strong>关键字的值</strong>有序，这样一来，关键字最小（或最大）的数据项就总是在队头。数据项插入的时候会按照顺序插入到合适的位置以确保队列的顺序。</p><h1 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h1><ul><li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li><li>消息队列</li><li>操作系统的进程调度</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO流</title>
    <link href="/2022/03/23/Java%E5%9F%BA%E7%A1%80%20-%20IO%E6%B5%81/"/>
    <url>/2022/03/23/Java%E5%9F%BA%E7%A1%80%20-%20IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>I&#x2F;O技术用于处理设备之间的数据传输,如读&#x2F;写文件，网络通信等。而“流（stream）”则是Java程序中对于数据的操作的处理方式。</p></blockquote><h1 id="获取键盘输入常用的两种方法"><a href="#获取键盘输入常用的两种方法" class="headerlink" title="获取键盘输入常用的两种方法"></a>获取键盘输入常用的两种方法</h1><p>方法 1：通过 <code>Scanner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span>  <span class="hljs-operator">=</span> input.nextLine();<br>input.close();<br></code></pre></td></tr></table></figure><p>方法 2：通过 <code>BufferedReader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.readLine();<br></code></pre></td></tr></table></figure><h1 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h1><blockquote><p>按操作数据单位不同分为：字节(byte)流，字符(char)流</p><p>按数据流的流向不同分为：输入流(InputStream)，输出流(OutputStream)</p><p>按流的角色的不同分为：节点流，处理流</p></blockquote><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>​        字节（Byte）是计算机操作数据的最小单位，在Java中由8位bit组成，取值为（-128 ~ 127)。字节流操作byte类型的数据，主要操作类是OutputStream、InputStream的子类；不用缓冲区，直接对文件本身操作。</p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>​        字符（char）是用户的可读写的最小单位，在Java中由16位bit组成，取（0~65535）。字符流操作char类型数据，主要操作类是Reader、Writer的子类；使用缓冲区缓冲字符，不关闭流就不会输出任何内容。</p><blockquote><p><em>字节流与字符流之间可以相互转换，只需要用两个类：</em></p><ul><li>*OutputStreamWriter ：字符流转字节流</li><li><em>InputStreamReader ：   字节流转字符流</em></li></ul></blockquote><p>​        不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，Java使用字符流的意义在于，字符流是由 Java 虚拟机将字节转换得到的，这个过程非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h2 id="输入流、输出流"><a href="#输入流、输出流" class="headerlink" title="输入流、输出流"></a>输入流、输出流</h2><p>把对象读入到存储介质中，即为输入。从存储介质中向外读数据，即为输出。</p><br/><h2 id="节点流-文件流"><a href="#节点流-文件流" class="headerlink" title="节点流(文件流)"></a>节点流(文件流)</h2><blockquote><p>节点流，即直接从数据源或目的地读写数据</p></blockquote><ul><li>在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文<br>件将被覆盖。</li><li>如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，<br>在文件内容末尾追加内容。</li><li>在读取文件时，必须保证该文件已存在，否则报异常。</li><li>字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt</li><li>字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。</li></ul><br/><h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><blockquote><p>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p><p>可分为六种：缓冲流、转换流、标准输入，输出流、打印流、数据流对象流</p></blockquote><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><ul><li>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区</li><li>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：BufferedInputStream 和 BufferedOutput，StreamBufferedReader 和 BufferedWriter</li><li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</li><li>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</li><li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，<br>BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法<br>flush()可以强制将缓冲区的内容全部写入输出流</li><li>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也<br>会相应关闭内层节点流</li><li>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷<br>新缓冲区，关闭后不能再写出</li></ul><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><ul><li>Java API提供了两个转换流：</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">InputStreamReader</span>：将<span class="hljs-built_in">InputStream</span>转换为<span class="hljs-variable">Reader</span><br><span class="hljs-variable">OutputStreamWriter</span>：将<span class="hljs-variable">Writer</span>转换为<span class="hljs-built_in">OutputStream</span><br></code></pre></td></tr></table></figure><ul><li>字节流中的数据都是字符时，转成字符流操作更高效。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">InputStreamReader<br>  实现将字节的输入流按指定字符集转换为字符的输入流。<br>  需要和InputStream“套接”。<br>  构造器:<br>  public <span class="hljs-constructor">InputStreamReader(InputStream <span class="hljs-params">in</span>)</span><br>  public <span class="hljs-constructor">InputSreamReader(InputStream <span class="hljs-params">in</span>,String <span class="hljs-params">charsetName</span>)</span><br>  如： Reader isr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">InputStreamReader(System.<span class="hljs-params">in</span>,”<span class="hljs-params">gbk</span>”)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">OutputStreamWriter<br> 实现将字符的输出流按指定字符集转换为字节的输出流。<br> 需要和OutputStream“套接”。<br> 构造器:<br> <span class="hljs-keyword">public</span> OutputStreamWriter(OutputStream <span class="hljs-keyword">out</span>)<br> <span class="hljs-keyword">public</span> OutputSreamWriter(OutputStream <span class="hljs-keyword">out</span>,<span class="hljs-keyword">String</span> charsetName<br><br></code></pre></td></tr></table></figure><br/></li></ul><br/><ul><li><strong>转换流的编码应用</strong></li></ul><p><em>可以将字符按指定编码格式存储<br>可以对文本数据按指定编码格式来解读<br>指定编码表的动作由构造器完成</em></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><blockquote><p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p></blockquote><ul><li>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所<br>提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异<br>常信息。</li><li>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描<br>述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资<br>源也可以不存在。</li><li>在以前IO操作都是这样写的:</li></ul><p><em>import java.io.File;<br>File file &#x3D; new File(“index.html”);</em><br>但在Java7 中，我们可以这样写：<br><em>import java.nio.file.Path;<br>import java.nio.file.Paths;<br>Path path &#x3D; Paths.get(“index.html”);</em></p><ul><li>Paths 类提供的静态 get() 方法用来获取 Path 对象：<ul><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri):                                   返回指定uri对应的Path路径</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表 (java)</title>
    <link href="/2022/03/23/Java%E5%9F%BA%E7%A1%80%20-%20%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/03/23/Java%E5%9F%BA%E7%A1%80%20-%20%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表-LinkList"><a href="#链表-LinkList" class="headerlink" title="链表(LinkList)"></a>链表(LinkList)</h1><blockquote><p>链表是一种线性表，但并<strong>不按线性的顺序</strong>存储数据，使用的也不是<strong>连续的内存空间</strong>来存储数据。</p></blockquote><blockquote><p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。 </p></blockquote><blockquote><p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以<strong>充分利用计算机内存空间</strong>,实现灵活的<strong>内存动态管理</strong>。但链表不会节省空间，相比于数组会<strong>占用更多的空间</strong>，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p></blockquote><p>相对于数组，链表的优点： </p><ul><li>可灵活地分配内存空间，内存利用率高。链表是一种动态数据结构，可以在运行时通过分配和取消分配内存来增长和缩小。</li><li>能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。</li><li>易插入和删除元素。在链表中进行插入和删除节点很容易。只需要更新节点下一个指针中的地址。</li></ul><p>缺点：</p><ul><li><p>每次读取元素，都需要从链表头开始一个一个地读取，效率太低。</p></li><li><p>查询第n个元素需要O（k）时间，时间复杂度高。</p></li></ul><br/><h2 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h2><h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h3><pre><code class="hljs">     &lt;u&gt;**单向链表**&lt;/u&gt; 只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。      Java中单链表的创建：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> linklist;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data=data;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2.双向链表"></a>2.双向链表</h3><p><u><strong>双向链表</strong></u> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><pre><code class="hljs">Java中双向链表的创建：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    Node next; <br> <span class="hljs-comment">//存放下一个元素的引用地址，尾结点的通常为null。</span><br>    Node prev;             <br> <span class="hljs-comment">//存放上一个元素的引用地址，头结点的通常为null。若</span><br> <span class="hljs-comment">//若尾结点的next值指向头结点，则为双向循环链表，且头结点的prev指向尾结点，则为双向循环链表</span><br>    Object element;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node next, Node prev, Object element)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>        <span class="hljs-built_in">this</span>.element = element;<br>     &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-built_in">this</span>.element = node;<br>        node.next = <span class="hljs-literal">null</span>;<br>        node.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-循环链表"><a href="#3-循环链表" class="headerlink" title="3.循环链表"></a>3.循环链表</h3><p><u>**循环链表 **</u>其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p><p>代码的实现上与单链表类似，只是尾结点不再为null，而是指向头结点</p><br/><h3 id="4-双向循环链表"><a href="#4-双向循环链表" class="headerlink" title="4.双向循环链表"></a>4.双向循环链表</h3><p><u><strong>双向循环链表</strong></u> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p>代码的实现上与双向链表类似，但是尾结点的next值指向头结点，头结点的prev指向尾结点。</p><br/><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>链表适用于需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的时候。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈 (java)</title>
    <link href="/2022/03/22/Java%E5%9F%BA%E7%A1%80%20-%20%E6%A0%88/"/>
    <url>/2022/03/22/Java%E5%9F%BA%E7%A1%80%20-%20%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h1><blockquote><p>栈 (stack)又称堆栈，只允许在表的一端进行加入数据（push）和移除数据（pop）。因而按照 后进先出（LIFO, Last In First Out） 的原理运作。通常称能够进行插入、删除运算的一端为&#x3D;&#x3D;栈顶&#x3D;&#x3D;（Top），另一端称为&#x3D;&#x3D;栈底&#x3D;&#x3D;（Bottom）。当表中没有元素的时候称为空栈。</p></blockquote><p><code>空栈时最先插入的元素总被放在栈的底部，只有所有元素被移除（弹出）后，它才能被删除</code></p><p><code>栈的存储结构有顺序存储结构和链式存储结构两种。在顺序栈中，可以考虑栈的上溢；在链式栈中，不必考虑栈的上溢，只需要考虑栈的下溢</code></p><p>栈的上溢是一种出错状态，应该设法避免；而下溢则是正常现象，可作为程序控制转移的条件</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p><strong>顺序栈</strong> 常用一维数组来实现</p><p>Java代码实现: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] storage;<span class="hljs-comment">//存放栈中元素的数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//栈的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<span class="hljs-comment">//栈中元素数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">GROW_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">//不带初始容量的构造方法。默认容量为8</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = <span class="hljs-number">8</span>;<br>        <span class="hljs-built_in">this</span>.storage=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//带初始容量的构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Capacity too small.&quot;</span>);<br><br>        <span class="hljs-built_in">this</span>.capacity = initialCapacity;<br>        <span class="hljs-built_in">this</span>.storage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[initialCapacity];<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><p><strong>链式栈</strong> 常用链表来实现</p><p>Java代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-keyword">public</span> E e;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E e, Node next)</span>&#123;<br>            <span class="hljs-built_in">this</span>.e = e;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E e)</span>&#123;<br>            <span class="hljs-built_in">this</span>(e, <span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><br/><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><h3 id="浏览器的回退和前进"><a href="#浏览器的回退和前进" class="headerlink" title="浏览器的回退和前进"></a>浏览器的回退和前进</h3><pre><code class="hljs">    我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。</code></pre><br/><h3 id="反转字符"><a href="#反转字符" class="headerlink" title="反转字符"></a>反转字符</h3><pre><code class="hljs">    利用栈后进先出的特征，将栈中的每个字符先入栈，再出栈即可。</code></pre><br/><h3 id="分隔符匹配"><a href="#分隔符匹配" class="headerlink" title="分隔符匹配"></a>分隔符匹配</h3><pre><code class="hljs">    栈通常用于解析某种类型的文本串。通常，文本串是用计算机语言写的代码行，而解析它们的程序就是编译器。    分隔符匹配程序从字符串不断地读取字符，若它是左分隔符，则压入栈中。当从输入中读取到一个右分隔符时，弹出栈顶的左分隔符，并查看它和右分隔符是否匹配。如果栈中没有匹配的左右分隔符，或栈中一直存在着没有被匹配的分隔符（所有字符读入后，栈中仍有分隔符），则程序报错。Java中的代码实现：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BracketChecker</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String s ;<br>        s = getString();<br>        <span class="hljs-type">BracketChecker</span> <span class="hljs-variable">bracketChecker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BracketChecker</span>(s);<br>        bracketChecker.check();<br>    &#125;<br>    <span class="hljs-keyword">private</span> String input;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BracketChecker</span><span class="hljs-params">(String input)</span> &#123;<br>        <span class="hljs-built_in">this</span>.input = input;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">()</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.toCharArray().length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> input.charAt(i);<br>            <span class="hljs-keyword">switch</span> (ch) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    stack.push(ch);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                        <span class="hljs-type">char</span> <span class="hljs-variable">chx</span> <span class="hljs-operator">=</span> stack.pop();<br>                        <span class="hljs-keyword">if</span> ((ch == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; chx != <span class="hljs-string">&#x27;&#123;&#x27;</span>) ||<br>                                (ch == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; chx != <span class="hljs-string">&#x27;[&#x27;</span>) ||<br>                                (ch == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; chx != <span class="hljs-string">&#x27;(&#x27;</span>)) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;解析异常：&quot;</span> + ch + <span class="hljs-string">&quot;在位置&quot;</span> +i);<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        System.out.println(<span class="hljs-string">&quot;解析异常：&quot;</span> + ch + <span class="hljs-string">&quot;在位置&quot;</span> +i);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!stack.isEmpty())&#123;<br>            System.out.println(<span class="hljs-string">&quot;字符串异常，遗失右分隔符&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;解析正确&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
